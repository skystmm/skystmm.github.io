<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖小天</title>
  <icon>https://www.gravatar.com/avatar/974f57050e4add8063a9d86027a8e541</icon>
  
  <link href="https://stxl117.top/atom.xml" rel="self"/>
  
  <link href="https://stxl117.top/"/>
  <updated>2025-06-22T08:55:59.791Z</updated>
  <id>https://stxl117.top/</id>
  
  <author>
    <name>胖小天</name>
    <email>stskymm@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于anythingLLM搭建本地知识库`</title>
    <link href="https://stxl117.top/2025/06/22/%E5%9F%BA%E4%BA%8EanythingLLM%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <id>https://stxl117.top/2025/06/22/%E5%9F%BA%E4%BA%8EanythingLLM%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93/</id>
    <published>2025-06-22T08:54:35.000Z</published>
    <updated>2025-06-22T08:55:59.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>书接上文，我们完成了deepseek模型的本地化部署，并通过pageAssist插件构建了我们第一个本地化聊天Agent。今天我们则通过anythingLLM 工具，从0到1搭建专属知识问答Agent。本文搭建过程无需任何编码经验</p></blockquote><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>访问<a href="https://anythingllm.com/">anythingLLM官网</a>，点击“Download for Desktop”按钮，并根据要安装的电脑的操作系统选择对应版本的anything LLM安装包下载</p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNhNTgzZWNkMWVlMjBmYjRmNzU0Mjg2MmRjMWFmMmNfM2gwNkM2N2loM3BLQ0ZJV2JqbnZUTVgxRVc5TlE3NzZfVG9rZW46SjNDaGJURXZQbzJSNmp4clNSM2N0aFRCbnhkXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE2YzU4YWNmNWQ2Zjg5ZDRkNjBkMmE2MDY0NWI2Yzlfc2JFU2Z6OGdqdkFkbGJ5Q2Voelg1Tlh2dVhWdkIzM1dfVG9rZW46UW5oTGJnV3N4b0pveEd4czhUNWNSZ0N1bnVlXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>下载完成后，根据安装导引进行anythingLLM的安装</p><h2 id="基础配置及使用"><a href="#基础配置及使用" class="headerlink" title="基础配置及使用"></a>基础配置及使用</h2><blockquote><p><a href="https://docs.anythingllm.com/configuration">https://docs.anythingllm.com/configuration</a></p></blockquote><h3 id="工作区基础配置"><a href="#工作区基础配置" class="headerlink" title="工作区基础配置"></a>工作区基础配置</h3><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdmY2YwMzA4NDhiMWFmMmFjZjQ0ZGYyMTIzYzI3NzBfTFd0aXJTT0hNdUZaZ0djMmU3RUpRZTkxeG41VEt2Q01fVG9rZW46SGVzNWJDRk1Jb0tJaG14bDRLcmNHTjZnbm9kXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>第一次打开AnythingLLM可以通过新建工作区 来建立自己专属的工作区，创建完成后，可以点击工作区名称右侧的“齿轮”按钮进入工作区设置页面，在“聊天设置”选项卡汇总进行模型基础信息设置</p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJjYzdmMjMyOWU1NjI3MTA2MWMwODliZDgwYjQ3MGFfaHNDQ3M2M0dOQnRZd3BPemx6dVl0U2NwM0M2aG5xb2FfVG9rZW46UnpOeWJDQmN0b2hXenB4STNnTmM2UkhTbkxnXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBiOWZmZGI2ZmVmOGQzYmY5MzM0MDJlNmZjYjg0NjZfbmNTek9MQVB4Tlp0OWNtVnF6dkFNTzdibHEydFR1N05fVG9rZW46UzJKNGJwMnpVb205Vnh4cUVyemNtTTBIblVoXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>本次我们设置基座模型为Qwq-32B的本地版本，所以<code>工作区LLM提供者</code>选择<code>Ollama</code>,模型选择已经下载好的<code>Qwq-32B</code>(Ollama 安装及下载本地模型可以参考<a href="https://gfupsplgl5.feishu.cn/docx/XSjid7Ji4ogoHxxvbcZcC8EQnhc">基于deepseek本地化对话机器人搭建</a>)，如果使用其他公用模型可以<code>工作区LLM提供者</code> 选择相应的模型信息，并配置相应AK&#x2F;SK信息，AnythingLLM中基本涵盖了目前流行的模型信息。</p><h3 id="构建个人知识库"><a href="#构建个人知识库" class="headerlink" title="构建个人知识库"></a>构建个人知识库</h3><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Y2ZDA5NDIwZWZkMjFiZjNhZTkxY2FiOTI5OWIxODRfckFTN1VTWk9zNGRvdXZBbnNRU2dlN3E3QzJneGR0QndfVG9rZW46RE9FU2JEZ3pxbzdOM1h4Y2hac2M1dm52blRnXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>通过工作区名称右侧的“上传”按钮拉起知识库上传面板</p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjU1MDYzYjU3OWEyYzkwZGU4MTVhOTBhNmUyYjYzNDFfY2x5RWZlQVpuWWVHME02U25teUx5WXlBSXZrR0tYbXNfVG9rZW46TnRsSGJpencyb0YxdTN4UGdua2NxMVgxbkZnXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>anythingLLM支持文档上传和通过连接获取一些渠道的数据（目前支持github,gitlab,youtube以及网页爬取），点击上传 并选择相应文件后，等待上传完成后，点击发布到工作区后，在点击“Save and Embed” 即可对上传文件进行向量化处理，等待embed完成后，工作区就可以使用相应知识库来帮助问答。</p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzFhMzI3OWFjNjI0ZmM3MTNiNjIyNDQ4NzFjNjcwNmFfVUhESEp2YWN1djMzVVd4TXM4dkMybnZoeEd3N1B5akRfVG9rZW46T3g4YmJUNk1jb2Zzcnd4REdiSGMxUEZ1bm1mXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODFmNWEzZWJiZWI1YTgyZjhmN2MyMGFlYTc4MTQ0NzlfWW1IZHBaQ0VKekRuU2N0VmJ0SXVhZWJsbUtZRjg0UzhfVG9rZW46WDZlVmJ6WGVob0tCcVJ4VVlvcWN6QWJQblJOXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><h3 id="开启对话"><a href="#开启对话" class="headerlink" title="开启对话"></a>开启对话</h3><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJlMjdjNjE2MTA5NGY2YzdhYzEzNWNhZWRkYWE3Y2ZfR09ETGZtd1pVamwwZW1xZkx2OU5TM2llUnpyYVFaekhfVG9rZW46RWNMbGJZb1FPb0VJWFZ4bEVsQ2NTMmlJbmFlXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><h2 id="一些其他扩展"><a href="#一些其他扩展" class="headerlink" title="一些其他扩展"></a>一些其他扩展</h2><h3 id="联网搜索配置"><a href="#联网搜索配置" class="headerlink" title="联网搜索配置"></a>联网搜索配置</h3><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjg0YTlmZTQ5ODQ3ZmZiOWU0MmUxYThiM2U3MGZlYzBfWVNWNkpsa3FYMnV3OHlldW5FSzAxRXRNNVFLSWNnWmFfVG9rZW46Q0plWWJUb0VXb2pCMER4RlY5N2NSWlowbmJnXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>跳转至AnythingLLM的通用配置，目前提供以下</p><p><img src="https://gfupsplgl5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTAwOTdkZjZkOGZiNTYwMDJkYjQyYjE1ZjQ1YzRlNzVfSmRqM1V0UGlINTBqdWdkNjljc0EzenlIVVZ4WURNRDdfVG9rZW46SXVyeGI4V1NKbzAwbWV4TjJTZWNCbzcxbnFLXzE3NTA1ODI1NTY6MTc1MDU4NjE1Nl9WNA"></p><p>anythingLLM默认网络搜索为关闭状态，需要手动打开，并选择要使用的搜索插件并完成对应配置，即可体验问答搜索能力。完成配置后需要再右上角点击save按钮才可生效。</p><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><blockquote><p><a href="https://docs.anythingllm.com/agent/custom/developer-guide">https://docs.anythingllm.com/agent/custom/developer-guide</a></p></blockquote><p>仅提供anythingLLM 定制插件开发文档，细节不在本文中赘述</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;书接上文，我们完成了deepseek模型的本地化部署，并通过pageAssist插件构建了我们第一个本地化聊天Agent。今天我们则通过anythingLLM 工具，从0到1搭建专属知识问答Agent。本文搭建过程无需任何编码经验&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="LLM学习" scheme="https://stxl117.top/categories/LLM%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="deepseek" scheme="https://stxl117.top/tags/deepseek/"/>
    
    <category term="LLM学习" scheme="https://stxl117.top/tags/LLM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于deepseek本地化对话机器人搭建</title>
    <link href="https://stxl117.top/2025/02/15/ds-local/"/>
    <id>https://stxl117.top/2025/02/15/ds-local/</id>
    <published>2025-02-15T11:08:34.000Z</published>
    <updated>2025-02-15T13:57:32.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随时deepseek春节的爆火出圈，通过deepseek官网使用AI对话能力，出现稍后再试的概率越来越高。deepseek又开源了模型，本着自己动手丰衣足食的想法，尝试通过本地搭建私人订制的AI，后续会考虑搭建本地代码生成机器人来提升工作效率。</p></blockquote><h1 id="ollama安装"><a href="#ollama安装" class="headerlink" title="ollama安装"></a>ollama安装</h1><p>根据搭建环境系统信息<a href="https://ollama.com/download">下载Ollama</a> 对应版本到本地</p><p><img src="/images/ollama.jpg"></p><p>下载完成后，根据安装提示进行ollama安装，安装完成后在命令行输入</p><blockquote><p>&gt; ollama -v&amp;#x20;</p><p>ollama version is 0.5.7</p></blockquote><p>输出ollama版本这说明ollama安装成功，通过下列命令拉取和运行相应版本deepseek模型</p><blockquote><p>&gt;  ollama run deepseek-r1:7b</p></blockquote><p>目前<a href="https://huggingface.co/deepseek-ai/DeepSeek-R1">Deepseek-r1 提供</a> 如下几种不同参数r1模型</p><p><img src="/images/ds_model.jpg"></p><h1 id="可视化UI对话机器人搭建"><a href="#可视化UI对话机器人搭建" class="headerlink" title="可视化UI对话机器人搭建"></a>可视化UI对话机器人搭建</h1><h2 id="Chatbox搭建可视化本地对话机器人"><a href="#Chatbox搭建可视化本地对话机器人" class="headerlink" title="Chatbox搭建可视化本地对话机器人"></a>Chatbox搭建可视化本地对话机器人</h2><ol><li><p><a href="https://chatboxai.app/zh">ChatBox官网下载</a> ，根据部署模型机器系统信息，选择相应系统版本进行下载</p></li><li><p>下载完成后根据提示进行安装</p></li><li><p>在chatBox应用界面点击设置后</p></li></ol><p><img src="/images/chatbox_setting.jpg"></p><p>“模型”选项卡中，“模型提供方”选择“Ollama API”，“模型”选择 1步骤中通过ollama 拉取的deepseek模型。</p><ul><li>完成配置后，即可通过ChatBox来体验deepseek模型的对话能力</li></ul><p><img src="/images/chatbox_ui.jpg"></p><h2 id="LM-studio搭建可视化本地对话机器人"><a href="#LM-studio搭建可视化本地对话机器人" class="headerlink" title="LM studio搭建可视化本地对话机器人"></a>LM studio搭建可视化本地对话机器人</h2><ol><li><a href="https://lmstudio.ai/">LM Studio官网</a>，根据部署模型机器系统信息，选择相应系统版本进行下载</li></ol><p><img src="/images/lm.jpg"></p><ul><li><p>下载完成后根据提示进行安装</p></li><li><p>模型下载和配置，通过点击左侧栏的”搜索”按钮，在“model search”选项卡中，选择想要使用的模型进行下载</p></li></ul><p><img src="/images/lm_setting.jpg"></p><ul><li>模型下载完成后，下聊天页面点击“select a model to load”选择刚刚下载的模型，即可开启deepseek模型对话能力</li></ul><p><img src="/images/lm_select_model.jpg"></p><p>以上两种方式都可以快速可视化的体验本地deepseek模型对话能力，美中不足两种方式deepseek模型都无法在对话时，获取和总结相关网络搜索信息。</p><h1 id="联网搜索及知识库扩展"><a href="#联网搜索及知识库扩展" class="headerlink" title="联网搜索及知识库扩展"></a>联网搜索及知识库扩展</h1><p>本地模型联网搜索能力可以通过chrome插件 page assist  进行支持，通过chrome插件商店下载<a href="https://chromewebstore.google.com/detail/page-assist-%E6%9C%AC%E5%9C%B0-ai-%E6%A8%A1%E5%9E%8B%E7%9A%84-web/jfgfiigpkhlkbnfnbobbkinehhfdhndo?hl=zh-CN&utm_source=ext_sidebar">page assist</a>并安装(<a href="https://github.com/n4ze3m/page-assist">github:page assist</a>)。</p><h2 id="搜索设置"><a href="#搜索设置" class="headerlink" title="搜索设置"></a>搜索设置</h2><p>chrome浏览器的插件管理中点击 page assist图标即可唤起 page assist web页面，如下图，点击右上角设置按钮，进入设置页面，选择“General Setting” 进行搜索设置</p><p><img src="/images/pa_settings.jpg"></p><p><img src="/images/pa_search.jpg"></p><p>在“Manage Web Search”下选择使用的搜索引擎，选择完成后点击“Save”按钮保存设置。</p><h2 id="常用prompt设置（可选）"><a href="#常用prompt设置（可选）" class="headerlink" title="常用prompt设置（可选）"></a>常用prompt设置（可选）</h2><p>可以在设置页面，选择”Manage Prompt”选项卡，设置常用提示词。</p><p><img src="/images/pa_prompt.jpg"></p><h2 id="开启对话"><a href="#开启对话" class="headerlink" title="开启对话"></a>开启对话</h2><p><img src="/images/pa_main.jpg"></p><p>返回首页，页面中选择要使用的本地模型，同时可以选择刚设置的常用prompt，在点击对话框中的联网按钮为“On”,就可以开始本地模型联网对话了</p><p><img src="/images/pa_intel.jpg"></p><h2 id="Knowledge设置"><a href="#Knowledge设置" class="headerlink" title="Knowledge设置"></a>Knowledge设置</h2><p>依然通过右上角设置界面进入设置页,在上传knowledge前，先在”RAG Settings”对embading model进行配置</p><p><img src="/images/pa_knowledge.jpg"></p><p>配置完成后，通过左侧栏选择”Manage Knowledge”选项卡，进入知识库配置页面，点击“Add New Knowledge” 来创建知识库内容，目前page assist支持pdf,csv,txt,md,docx五种类型知识上传</p><p><img src="/images/pa_add.jpg"></p><p><img src="/images/pa_add2.jpg"></p><p>上传后，等待embading模型处理完成，即可在对话中引入知识库</p><p><img src="/images/pa_use_knowledge.jpg"></p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>Page assist 插件通过浏览器插件轻量级的支持ollama本地模型接入，能够快速体验本地模型对话能力，能够快捷接入网络搜索和知识库能力，但是网络搜索和知识库不能并行使用，同时网络搜索只能使用单一搜索引擎，知识库支持常用文本类型，但不支持网络信息导入或者代码库接入。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Ollama作为本地化部署模型的基底，同时提供简单便捷的模型拉取命令，是本地化部署模型的有力提效工具。市面上各种可视化对话工具层出不穷，可以根据个人喜好进行选择。对于本地化部署deepseek模型</p><p>优点：可以避免deepseek的算力不足出现的超时问题；由于是本地部署，涉密高敏问题不会出现泄露问题</p><p>缺点：依赖硬件性能，一般机器无法使用满血671B模型，效果会差强人意。</p><p>大家可以根据个人诉求酌情选择使用deepseek官方或各大云商提供的满血deepseek模型，在工作中达到提效的目的，当然想尝试本地化部署体验从0到1搭建本地化个人助手也是一个不错的体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;随时deepseek春节的爆火出圈，通过deepseek官网使用AI对话能力，出现稍后再试的概率越来越高。deepseek又开源了模型，本着自己动手丰衣足食的想法，尝试通过本地搭建私人订制的AI，后续会考虑搭建本地代码生成机器人来提升工作效率。&lt;/</summary>
      
    
    
    
    <category term="LLM学习" scheme="https://stxl117.top/categories/LLM%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="deepseek" scheme="https://stxl117.top/tags/deepseek/"/>
    
    <category term="LLM学习" scheme="https://stxl117.top/tags/LLM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发学习笔记（一）</title>
    <link href="https://stxl117.top/2024/08/11/wx-app-1/"/>
    <id>https://stxl117.top/2024/08/11/wx-app-1/</id>
    <published>2024-08-11T13:38:29.000Z</published>
    <updated>2025-02-15T11:12:03.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/tap.html">微信小程序官方文档</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/view/tap.html&quot;&gt;微信小程序官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="小程序" scheme="https://stxl117.top/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="小程序" scheme="https://stxl117.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>胖小天2024随想</title>
    <link href="https://stxl117.top/2024/06/14/2024_1/"/>
    <id>https://stxl117.top/2024/06/14/2024_1/</id>
    <published>2024-06-14T13:07:42.000Z</published>
    <updated>2025-02-15T13:36:36.564Z</updated>
    
    <content type="html"><![CDATA[<p>翻了下自己之前的博客，上次写类似内容还是20年初，对19年的回顾和新的一年的展望，年初本来想写去年年终终结，后来因为种种原因不了了之。所以这篇随想主要想对过去的四年的一些变化和思考进行一下记录，等若干年后回忆过往的时候有一个对比对照，可能会觉得当时的自己咋这么SX。<br>wahtever总的来说就是像记录下当下自己的一些状态和思考</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p><img src="https://image.stxl117.top/pic/img-20231021-8.jpg" alt="夜探梦想小镇"><br>这几年是到目前为止工作上最稳定的几年，打破了之前2+年就会换工作的故事，第一次在一家公司待了三年以上，到目前为止这个一家公司待得时间记录还在增加，也是一次在互联网大厂打怪升级的历练。</p><p>工作经历会比较繁杂，大体从工作城市上可以分为两端，刚毕业在帝都打拼和后来在杭州定居。从毕业进入正在步入夕阳的通信公司，到当时LD带我们出来创业，体验了从0到1搭建平台能力和从业务从单一城市网点一点点铺开到两城运营，虽然因为个人要换个城市的原因，和大家分道扬镳，但不得不承认这是一段回想起来收获颇丰的经历。但是共事的同学都是很nice的同学，能够包容我这个菜鸟犯各种低级错误，也能给与及时的从技术层面还是职业成长层面的指导和鼓励。同时也收获了很多友情，虽然大家现在很多都不在一个城市打拼，但是还是会有交流和沟通。后来从帝都来到了杭州，进入了一家安防企业做垂直领域应用层开发工作，待了一年的时间，感受到了工作方式和氛围上不是自己想要的方式后，跳槽到了一家互联网金融风控公司，刚好赶上公司从扩张到开始下山的2年时间，整体公司无论是技术氛围还是企业文化都觉得让人很舒服，但是因为一些特殊原因（也是一段神奇的经历），两年后还是选择了离开这家公司。</p><p>这时候还没有过任何互联网大厂经历的我对大厂有一份莫名的执着，想要去看看大厂到底是什么样的，里面的工作的同学是不是都是“三头六臂”，无所不能。通过自己的努力和沉淀，当然更重要的是运气，赶上了宇宙厂在杭州开office的大力招聘，才能如愿以偿的体验到在大厂工作的经历。记得在在两份工作之间的间隔时期刚好看完了《如何定义公司》、《重新定义团队》、《谷歌方法》三本书，当时对于google的企业文化，行事风格还是很向往的。当入职宇宙厂开始新员工视频学习时，看到提倡的企业文化和google所描述的何其相似，就觉得这里是我的dream company了。同时给自己也定了几个小目标，第一个就是一定要在这里待过三年，现在会看已经超额完成。</p><p>在当前工作的四年多工作经历中，经历了主动活水，被动调整等变化，身边的同事也是换了一波又一波。大家的行事风格，工作态度都各不相同，从一开始的努力跟上大家的节奏，不断学习如何把事情做好；到后来的帮助他人适应新工作环境。从一开始的闷头做事，到一点点去增加ownership和拉通协作。这几年在工作中更是收获颇丰，同时个人思维模式和行事风格也有了很大的变化，暂且不论好坏。当然工作和生活不可能全部都是好的一面，也会有很多不如意或者觉得不好的事情（这里先买个关子会在未来和思考的环节继续展开），也会有很多不愉快的事情，同时也会思考作为一个互联网大龄从业人员未来该何去何从。尤其是在当年的小目标都要实现的时候。</p><p>总的来说，这四年的工作经历还是收获颇多，改变颇大。但是这样的快速节奏终究对于我个人来说不是一个可以长久的事情。人生短短几十年，还是需要去探索更多的可能性，去体验更多不同的生活方式的。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p><img src="https://image.stxl117.top/pic/img-20220828-1.jpg" alt="松阳"></p><p>说到生活，最大的变化是校园爱情修成了正果，在杭州安了家。</p><p>关于爱好，有了一些新的爱好同时也有一些之前的爱好，慢慢淡出了生活。但这几年主要的经历在于努力攒钱，早日FIRE。但是从去年的某一天突然发现，这几年收入多了，但是每个月还是扣扣嗖嗖，生活上和之前基本没有什么变化。虽然我们在生活中都不是物欲高的人，但是这样一直压抑物欲，经常会带来报复性消费和非理性消费，反而得不偿失。今年开始我们在攒钱的基础上，还是要增加一些爱好方向的支出预算和生活结余强制预算。</p><p><img src="https://image.stxl117.top/pic/img-20240327-12.jpg" alt="杭州夜樱"><br>其余的方面其实也是按部就班，每天早出晚归，努力在各自的公司做这社畜。周末有精力的时候就出去玩玩，没有精力则在家躺平。关于拍照还是在一个学习和探索的阶段，希望今年可以拿到两个平台的签约，虽然两年前就立了这个flag一直拖延到今年还没能完成；同时希望可以多出去走走，去体验不同地方的风土人情，见到更多不一样的人怎么过自己的生活；关于新爱好，和老婆开始喜欢上骑行，我们从新买了自行车就此开启了周末4+2模式，感兴趣的话可以关注我的抖音，会记录每一次4+2骑行的过程以及旅行中拍到的好照片。最后呢，还是要利于空余时间多看看书，而且范围不局限于技术领域，更多的去看看不同领域的书籍，包括但不限于投资理财，历史，人物传记等等。</p><p>最后放一些这几年觉得拍的还不错的照片，来记录下这几年的足迹</p><table style="table-layout: fixed;" border="1" width="100%" cellspacing="0" cellpadding="2"><tr><td><center><img src=https://image.stxl117.top/pic/img-20220910-2.jpg  />玉皇山顶看西湖 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20231215-1.jpg  />西湖鸳鸯戏水 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20231215-3.jpg  />雷峰塔 </center></td></tr><tr><td><center><img src=https://image.stxl117.top/pic/img-20221005-3.jpg  />覆卮山梯田 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20240217-11.jpg />徐家汇天主教堂 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20240216-8.jpg  /> 东方明珠</center></td></tr></table><table style="table-layout: fixed;" border="1" width="100%" cellspacing="0" cellpadding="2"><tr><td><center><img src=https://image.stxl117.top/pic/img-20221215-6.jpg  />杨公堤航拍 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20231223-10.jpg  />智慧网谷航拍夕阳 </center></td></tr><tr><td><center><img src=https://image.stxl117.top/pic/img-20221106-4.jpg  />中国金钱松森林公园 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20221218-7.jpg  />钱江一桥夕阳 </center></td></tr><tr><td><center><img src=https://image.stxl117.top/img-20231126-16.jpg  />大版环球影城 </center></td><td><center><img src=https://image.stxl117.top/pic/img-20231125-9.jpg />奈良法华寺 </center></td></tr></table><blockquote><p>p.s. 几个题外又觉得应该记录一下的事情</p><ol><li>这两年升级了一些设备,购置了一台无人机，更新换代了相机（出佳为尼），最近有入手了运动相机（虽然很快被新品被刺）</li><li>竟然可以主动撸狗，同时觉得养小动物也不是完全不能接受</li></ol></blockquote><h2 id="一些改变"><a href="#一些改变" class="headerlink" title="一些改变"></a>一些改变</h2><p><img src="https://image.stxl117.top/pic/img-20231223-10.jpg" alt="智慧网谷航拍夕阳"><br>记得有一天因为有事提前下班，竟然在去地铁站的路上看到了夕阳，当时会觉得有夕阳相伴的下班路或者说天黑前可以下班是一件多么幸福的事，后面和老婆聊起这个感受，然后会看从毕业到当下的十来年的时间，我们总是在努力的工作，在工作中变成别人眼中更好的自己，而我们自己对于生活的感知却也慢慢变成了两点一线的平凡，加之为了让周末更加有意义的快节奏“享受”休息时光，却忘却了生活的本质是什么？这里想起在北京刚工作的几年，总是用一句带有自嘲的话激励自己更加努力的工作——<code>当下努力的生和活，为了将来可以真正的生活</code>。现在会看挣的钱多了，每个月也开始有了一定储蓄，也能有余钱做一些投资，但是生活还是在一个被追赶的状态，并当下并没有带来什么快乐，只是为了自己臆想中未来的快乐生活而努力，这到底是不是对的？</p><p>所以换个角度，开始尝试让节奏变慢一点，从一个被追赶着慢慢的去尝试掌握和把控时间，用有限的时间去体验更多的未知。能想到的一些改变从去年在上下班路上开始听播客，从去参加了一次本以为没法坚持下来的南天老师的青训营，从开始更加关注投资理财，从周末一起去听音乐会，从骑行探索不一样的杭州及其周边，总之希望未来可以想到就去做，通过这种方式让自己的人生更加多元。</p><p>接受平庸和自己和解，这两年慢慢从之前的和自己较劲的状态中慢慢的走出来，能够更加从容的接受自己的不足以及不在事事都想挣第一。然后就会发现生活没有以前那么处处为难你，反而日常中很多小事都可以让自己得到满足，但是还是没有完全做到，需要时间一点点的去改变，让自己在生活中更容易感知到快乐和幸福，这样相应的不开的占比就会减少。其实降低预期是一件成本低会报高的事情，何乐而不为呢。</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p><img src="https://image.stxl117.top/pic/img-20221211-5.jpg" alt="北湖草荡夕阳"><br>随着人生阅历的慢慢增长，认知一点点的扩宽。隐约的觉得，生活的意义不仅仅是工作，不仅仅是拥有很多钱，而是找到让自己快乐舒适的生活的方式。<br>从这个角度出发，未来可能会考虑尝试一些自己喜欢的事情，看看能不能在工作和快乐生活中找到一个平衡点。会去探索新的生活方式，比如旅居，作数字游民，出去看看这个广阔的世界等等，能够从中收获之前三十年没法接触到的人和事，也是一种不错的选择。<br>总的来说，从思想上觉得未来几十年的人生，可能会有更多的可能性，但是从物质和决心上，还没有真正的迈出第一步。希望在未来的几年内可以真的勇于走出第一步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻了下自己之前的博客，上次写类似内容还是20年初，对19年的回顾和新的一年的展望，年初本来想写去年年终终结，后来因为种种原因不了了之。所以这篇随想主要想对过去的四年的一些变化和思考进行一下记录，等若干年后回忆过往的时候有一个对比对照，可能会觉得当时的自己咋这么SX。&lt;br&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://stxl117.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://stxl117.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://stxl117.top/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    <category term="胖小天的碎碎念" scheme="https://stxl117.top/tags/%E8%83%96%E5%B0%8F%E5%A4%A9%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="https://stxl117.top/2023/11/22/docker-cmd/"/>
    <id>https://stxl117.top/2023/11/22/docker-cmd/</id>
    <published>2023-11-22T15:00:54.000Z</published>
    <updated>2024-06-30T09:09:16.854Z</updated>
    
    
    
    
    <category term="docker" scheme="https://stxl117.top/categories/docker/"/>
    
    
    <category term="docker" scheme="https://stxl117.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>langchain学习笔记</title>
    <link href="https://stxl117.top/2023/10/09/langchan/"/>
    <id>https://stxl117.top/2023/10/09/langchan/</id>
    <published>2023-10-09T14:50:53.000Z</published>
    <updated>2024-06-30T09:09:16.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/langchain-ai/langchain">langchain-github</a><br><a href="https://www.langchain.com.cn/getting_started/getting_started">LangChain 🦜️🔗 中文网</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/langchain-ai/langchain&quot;&gt;langchain-github&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.langchain.com.cn/getting_st</summary>
      
    
    
    
    <category term="aigc" scheme="https://stxl117.top/categories/aigc/"/>
    
    
    <category term="aigc" scheme="https://stxl117.top/tags/aigc/"/>
    
  </entry>
  
  <entry>
    <title>&lt;System Desgin Interview -An insider&#39;s guide&gt;笔记</title>
    <link href="https://stxl117.top/2023/10/08/program-design/"/>
    <id>https://stxl117.top/2023/10/08/program-design/</id>
    <published>2023-10-08T08:43:08.000Z</published>
    <updated>2024-06-30T09:09:16.869Z</updated>
    
    <content type="html"><![CDATA[<p>先占坑</p><blockquote><p><a href="https://github.com/G33kzD3n/Catalogue/blob/master/System%20Design%20Interview%20An%20Insider%E2%80%99s%20Guide%20by%20Alex%20Xu%20(z-lib.org).pdf">System Desgin Interview -An insider’s guide</a><br><a href="https://www.alipan.com/s/ifYVFYtoLAi">System Desgin Interview Series</a></p></blockquote><p>这本书应该是一个同事推荐去年上半年读完的，当时觉得这本书与其说是给准备进行系统设计面试的同学的指导书籍，不如说是一本基础系统设计的基本思维指南，当时看完就准备写一篇读书笔记，记录一下当时的收获和思考，又一次搁浅。因为最近在主导业务系统重构，在重构的过程中又有了一些新的思考和收获，所以决定将本书学到的东西和最近做重构的思考整合记录一下。</p><p>本文主要会本书内容以及本次业务架构重构全过程，从思路和思考以及方方法论上进行分析，不会涉及技术点及其各种技术框架，基础组件及中间件原理；更不会涉及工作中任何的业务架构信息。如果想要通过本文了解真实业务架构和技术点信息的读者，可以跳过本文。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先占坑&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/G33kzD3n/Catalogue/blob/master/System%20Design%20Interview%20An%20Insider%E2%80%99s%2</summary>
      
    
    
    
    <category term="系统设计" scheme="https://stxl117.top/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://stxl117.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="系统设计" scheme="https://stxl117.top/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记（六）——context</title>
    <link href="https://stxl117.top/2023/09/27/go-context/"/>
    <id>https://stxl117.top/2023/09/27/go-context/</id>
    <published>2023-09-27T12:34:37.000Z</published>
    <updated>2024-06-30T09:09:16.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从转go语言开发开始，会发现在日常开发时，很多方法的入参的第一个参数都是<code>context.Context</code>。同时我们在代码逻辑中绝大部分情况下，不会对<code>context</code>继续任何处理。今天就来从源码的角度弄清楚Context是如何实现的及在程序中起到什么样的作用。</p><span id="more"></span><h1 id="Context源码解析"><a href="#Context源码解析" class="headerlink" title="Context源码解析"></a>Context源码解析</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package context defines the Context type, which carries deadlines,</span></span><br><span class="line"><span class="comment">// cancellation signals, and other request-scoped values across API boundaries</span></span><br><span class="line"><span class="comment">// and between processes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Incoming requests to a server should create a Context, and outgoing</span></span><br><span class="line"><span class="comment">// calls to servers should accept a Context. The chain of function</span></span><br><span class="line"><span class="comment">// calls between them must propagate the Context, optionally replacing</span></span><br><span class="line"><span class="comment">// it with a derived Context created using WithCancel, WithDeadline,</span></span><br><span class="line"><span class="comment">// WithTimeout, or WithValue. When a Context is canceled, all</span></span><br><span class="line"><span class="comment">// Contexts derived from it are also canceled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Programs that use Contexts should follow these rules to keep interfaces</span></span><br><span class="line"><span class="comment">// consistent across packages and enable static analysis tools to check context</span></span><br><span class="line"><span class="comment">// propagation:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not store Contexts inside a struct type; instead, pass a Context</span></span><br><span class="line"><span class="comment">// explicitly to each function that needs it. The Context should be the first</span></span><br><span class="line"><span class="comment">// parameter, typically named ctx:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//func DoSomething(ctx context.Context, arg Arg) error &#123;</span></span><br><span class="line"><span class="comment">//// ... use ctx ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not pass a nil Context, even if a function permits it. Pass context.TODO</span></span><br><span class="line"><span class="comment">// if you are unsure about which Context to use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use context Values only for request-scoped data that transits processes and</span></span><br><span class="line"><span class="comment">// APIs, not for passing optional parameters to functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The same Context may be passed to functions running in different goroutines;</span></span><br><span class="line"><span class="comment">// Contexts are safe for simultaneous use by multiple goroutines.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从Context包注释上可以看到，golang中定义context可以在函数调用链上，进程间以及服务间传递上下文信息，同时其中可以通过<code>WithCancel</code>,<code>WithDeadline</code>,<code>WithTimeout</code>,<code>WithValue</code>来增加上下文传递信息。同时当context触发cancel的时候，整个context链（为什么会说链，后面会介绍）都会被取消。 Context在gonlang中实现是协程间并发安全的。</p><blockquote><p>使用Context时需要注意</p><ol><li>在函数和方法入参需要传入Context时，如果调用链上有没有传入Context信息，不要使用nil来向下传递，使用 <code>context.TODO()</code> 或者<code>context.Background()</code>来进行context的传递</li><li>不要将Context作为其他Struct的属性定义，相反将context显示的通过函数和方法的首个参数继续传递</li><li>不要乱用Context将一些可选参数通过Context进行传递</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, a cancellation signal, and other values across</span></span><br><span class="line"><span class="comment">// API boundaries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context&#x27;s methods may be called by multiple goroutines simultaneously.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context需要实现<code>Deadline</code>,<code>Done</code>,<code>Err</code>,<code>Value</code>四个方法：</p><ol><li><code>Deadline</code>方法返回任务执行的结束时间以及是否设置了deadline信息，当设置了deadline同时执行时间到达deadline时间，则会出发cancel动作</li><li><code>Done</code>方法作用是在任务完成时调用，对整个context链进行取消操作；不同类型的context实现方式不同</li><li><code>Err</code>方法返回contenxt操作时出现的错误信息</li><li><code>Value</code>方法是遍历整个Context链来获取传入key对应的值信息</li></ol><h2 id="几种类型的Context"><a href="#几种类型的Context" class="headerlink" title="几种类型的Context"></a>几种类型的Context</h2><p><img src="https://image.stxl117.top/go_context.png" alt="Context的几种实现"></p><h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> background:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line"><span class="keyword">case</span> todo:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyCtx</code>是最基础的Context类型，从源码中可以看到<code>emptyCtx</code>是实现了了Context接口的<code>int</code>类型，并且可以看到日常使用的Context的最基础节点Background和TODO均为<code>emptyCtx</code>类型</p><h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line">mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c&#x27;s children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent&#x27;s children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line">d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done.Store(closedchan)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="propagateCancel方法"><a href="#propagateCancel方法" class="headerlink" title="propagateCancel方法"></a>propagateCancel方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span></span><br><span class="line"><span class="comment">// delegates all other calls to the embedded Context.</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context的链式结构"><a href="#Context的链式结构" class="headerlink" title="Context的链式结构"></a>Context的链式结构</h2><p>从context的源码中可看到，Context其实是一个链表结构，使用的Context在每次调用<code>WithXXX</code>方法后，使用头插法的方式将新Context作为Context链的队首进行返回</p><img  src=http://www.plantuml.com/plantuml/svg/iyfBBNSkgR3ciYf8B4hDAu6mY_BpmIm0><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h1><h2 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// any <span class="keyword">is</span> an alias <span class="keyword">for</span> <span class="keyword">interface</span>&#123;&#125; <span class="keyword">and</span> <span class="keyword">is</span> equivalent to <span class="keyword">interface</span>&#123;&#125; <span class="keyword">in</span> <span class="keyword">all</span> ways.</span><br><span class="line"><span class="keyword">type</span> <span class="type">any </span>= <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从转go语言开发开始，会发现在日常开发时，很多方法的入参的第一个参数都是&lt;code&gt;context.Context&lt;/code&gt;。同时我们在代码逻辑中绝大部分情况下，不会对&lt;code&gt;context&lt;/code&gt;继续任何处理。今天就来从源码的角度弄清楚Context是如何实现的及在程序中起到什么样的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>stable diffusion本地化部署</title>
    <link href="https://stxl117.top/2023/07/08/st-install/"/>
    <id>https://stxl117.top/2023/07/08/st-install/</id>
    <published>2023-07-08T07:58:58.000Z</published>
    <updated>2024-06-30T09:09:16.871Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>先占坑<br>cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/620297462">https://zhuanlan.zhihu.com/p/620297462</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;先占坑&lt;br&gt;cat id_rsa.pub &amp;gt;&amp;gt; ~&amp;#x2F;.ssh&amp;#x2F;authorized_keys&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhi</summary>
      
    
    
    
    <category term="aigc" scheme="https://stxl117.top/categories/aigc/"/>
    
    
    <category term="aigc" scheme="https://stxl117.top/tags/aigc/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记（五）——泛型</title>
    <link href="https://stxl117.top/2023/07/04/go-generics/"/>
    <id>https://stxl117.top/2023/07/04/go-generics/</id>
    <published>2023-07-04T14:50:09.000Z</published>
    <updated>2024-06-30T09:09:16.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a><br><a href="https://go.dev/blog/when-generics">When To Use Generics</a><br><a href="https://go.dev/blog/intro-generics">An Introduction To Generics</a><br><a href="https://go.dev/blog/deconstructing-type-parameters">Deconstructing Type Parameters</a></p></blockquote><h1 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h1><h1 id="泛型常用方法"><a href="#泛型常用方法" class="headerlink" title="泛型常用方法"></a>泛型常用方法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://go.dev/doc/tutorial/generics&quot;&gt;Tutorial: Getting started with generics&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://go.dev/blog/w</summary>
      
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>pulsar学习(一)</title>
    <link href="https://stxl117.top/2022/10/29/mq/"/>
    <id>https://stxl117.top/2022/10/29/mq/</id>
    <published>2022-10-29T14:32:33.000Z</published>
    <updated>2024-06-30T09:09:16.867Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>先占坑<br><a href="https://pulsar.apache.org/">pulsar官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;先占坑&lt;br&gt;&lt;a href=&quot;https://pulsar.apache.org/&quot;&gt;pulsar官网&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="消息队列" scheme="https://stxl117.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="pulsar" scheme="https://stxl117.top/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>一次线上panic排查记录</title>
    <link href="https://stxl117.top/2022/10/19/go_panic/"/>
    <id>https://stxl117.top/2022/10/19/go_panic/</id>
    <published>2022-10-19T14:38:11.000Z</published>
    <updated>2024-06-30T09:09:16.865Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>先占坑</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;先占坑&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记</title>
    <link href="https://stxl117.top/2020/11/22/redis/"/>
    <id>https://stxl117.top/2020/11/22/redis/</id>
    <published>2020-11-22T13:33:07.000Z</published>
    <updated>2024-06-30T09:09:16.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis基础知识"><a href="#redis基础知识" class="headerlink" title="redis基础知识"></a>redis基础知识</h1><span id="more"></span><p><img src="https://image.stxl117.top/redis.jpg" alt="redis思维导图.jpg"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><h4 id="整数数组"><a href="#整数数组" class="headerlink" title="整数数组"></a>整数数组</h4><h3 id="对外数据结构"><a href="#对外数据结构" class="headerlink" title="对外数据结构"></a>对外数据结构</h3><p>string</p><p>list</p><p>map</p><p>set</p><p>sorted set</p><blockquote><p>rehash如何触发和渐进式机制</p><ol><li><p>rehash触发根据负载因子阈值进行触发，不同于java中hashMap ，reids默认提供两个扩容负载因子阈值分别为1和5；</p></li><li><p>当负载系数达到1时， 如果当前redis server没有执行AOF重写或者RDB备份，会触发扩容</p></li><li><p>当负载系数达到5时，此时会立即触发阔扩容</p></li><li><p>rehash流程</p></li><li><p>rehash时会维护两个hash桶，一个是扩容前的老hash桶，一个是扩容后的新Hash桶</p></li><li><p>渐进式扩容方式为：</p></li><li><p>设置rehashIndex为0 表示开始扩容</p></li><li><p>当在rehash过程中，有客户端命令执行时，除了进行正常的操作外，还会将当前rehashindex对应的桶中数据迁移到新hash桶中，rehashindex 加一</p></li><li><p>当没有命令执行时，redis服务也会使用定时任务，执行迁移过程（每次执行不超过1ms）</p></li><li><p>当所有老hash桶中数据都迁移完成时 rehashindex设置为-1表名迁移结束</p></li><li><p>缩容[待学习]</p></li></ol></blockquote><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>6.0以前 单线程多路复用</p><p>6.0以后 多线程多路复用</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>redis中提供三种AOF的策略</strong>：</p><ol><li>always ——每次执行完写命令后立即写入AOF文件</li><li>every second ——每次执行完写命令后，先交AOF信息写到buffer中，每秒redis将buffer中的AOF信息写入到AOF日志中</li><li>no —— buffer写入AOF中的操作交友操作系统执行</li></ol><p>三种方式数据丢失情况有少到多，性能消耗由多到少</p><p>AOF的缺点：恢复时需要回放所有命令，相对恢复时间较长；由于记录每次操作，文件相对较大</p><p>由于AOF写存在对于相同Key的多次操作，相对会有重复和冗余，所以redis提供了AOF重写机制，来减小文件大小和回访时重复执行命令的问题</p><p><strong>AOF重写流程大致如下</strong>：</p><p>主进程fork出 bgrewriteaof进程，并将页表复制给子进程，子进程根据页表数据进行aof重写合并</p><p>操作过程中的写入命令，主进程将写到AOF重写缓冲中，也将共享给bgrewirteaof进程，自己成两者一起进行合并，生成洗的Aof日志并落盘</p><p>触发方法：</p><ol><li>手动执行bgrewriteaof命令</li><li>server周期性执行，满足以下条件会触发</li></ol><ul><li>没有BGSAVE命令（RDB持久化）&#x2F;AOF持久化在执行；</li><li>没有BGREWRITEAOF在进行；</li><li>当前AOF文件大小要大于<code>server.aof_rewrite_min_size</code>（默认为1MB），或者在<code>redis.conf</code>配置了<code>auto-aof-rewrite-min-size</code>大小；</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比（在配置文件设置了<code>auto-aof-rewrite-percentage</code>参数，不设置默认为100%）</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>redis中提供两个命令触发RDB备份 <code>save</code> 和<code>bgsave</code> 。</p><p><code>save</code> 命令是由主线程执行的对当前redis内存进行快照，执行时会阻塞主线程</p><p><code>bgsave</code> 命令则是由fork出子进程进行内存快照，除了fork过程，不会阻塞主线程执行命令；同时在进行快照过程中新处理的命令通过COW方式复制副本给子进程，来保证最后的一致性</p><p><img src="http://image.stxl117.top/rdb.png" alt="image.png" title="RDB"></p><p>同时Redis可以在配置文件中配置rdb的策略</p><p><code>save 900 1</code></p><p><code>save 300 10</code></p><p><code>save 60 10000</code>    </p><p>来配置rdb策略，上面命令900秒内少于1次变更操作就会触发一次主线程的rdb，以此类推。总体来说是server本身根据自身繁忙程度来确定什么时间进行备份。</p><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>上面记录了AOF和RDB的基本处理逻辑，会发现AOF和RDB各有各的优点，但也有各自的不足之处。例如AOF可以做到数据最少丢失，但是恢复时需要进行命令回放，速度会比较慢；而RDB则是通过快照的方式进行备份，恢复速度快，但是备份间隔期间出现宕机会丢失从上次备份到当前时间点的数据。可以看到二者有互补的地方，所有redis 4.0后支持了 RDB和AOF的混合模式保证数据可靠性</p><blockquote><p>选择什么样的备份策略还是要看业务形态等因素</p></blockquote><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="1-主从"><a href="#1-主从" class="headerlink" title="1. 主从"></a>1. 主从</h3><p><strong>主从同步流程</strong></p><p><strong><img src="http://image.stxl117.top/ms.png" alt="redisms.png" title="redisms.png"></strong></p><p><strong>同步方式： 全量同步（rdb），长连接命令传输，增量同步（重连后）</strong></p><blockquote><p>repl_backlog_buffer和replication buffer的区别</p><p>repl_backlog_buffer 为了主从差异数据设计的环形缓冲队列，只要有从库链接就会产生，所有从库共享</p><p>replication buffer 每个redis client的链接创建一个缓冲区，对于主从同步情况的特殊叫法，一般流程为Redis将返回数据写到该buffer中，然后再从该buffer中获取数据写入到对应的socket中返回给从库</p></blockquote><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p><strong>作用</strong></p><ol><li>监听</li></ol><p>主观下线：单个哨兵监听超时</p><p>客观下线：主观下线的数量大于等于配置的quorum值</p><ol start="2"><li><p>选主</p></li><li><p>筛选：当先在线且网络通信质量比较好的从库</p></li><li><p>打分</p></li><li><p>配置项中优先级最高的实例</p></li><li><p>slave_replication_offset最大的</p></li><li><p>runId最小的</p></li><li><p>通知</p></li></ol><p><strong>本质：****哨兵是一个特定模式的redis实例</strong></p><h4 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h4><p><strong>基本信息</strong></p><p>通过配置主库信息，链接主库，并通过pub&#x2F;sub机制获取其他哨兵服务抵制并发布自身ip信息，达到组网目的</p><p>从库信息通过使用INFO命令从主库中获得</p><p>客户端获取信息通过哨兵的pub&#x2F;sub方式获取变更信息</p><p><strong>哨兵集群选主——类似raft</strong></p><p>选票大于等于配置的quorum值，且大于等于集群节点 N&#x2F;2 + 1票</p><h4 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h4><p>水平扩展</p><p>去中心化</p><p>路由寻址：crc16的slot</p><p>数据迁移： move,ask,asking</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>对于redis提供的缓存淘汰策略，大致可以分为三类</p><ol><li>无缓存清理策略(noeviction) :不会进行缓存淘汰，使用本策略时，当redis内存达到阈值后，将会拒绝后续的写请求，直接返回错误</li><li>对于有过期时间的Key的淘汰策略:其中包含四种淘汰策略volitile-radom,volitile-ttl,volitile-lru,volitile-lfu</li><li>全局key淘汰策略:allkeys-lru,allkeys-lfu,allkeys-random</li></ol><p><strong>关于lru实现和一般lru算法不同的地方</strong>：</p><blockquote><p>LRU是对最近最不常使用的节点进行淘汰的策略，一般使用hashMap和双向链表实现</p></blockquote><p>由于redis中存在海量的key,同时内存也属于稀缺资源，如果维护一个全局双向链表将会产生很大的内存开销，所以redis对lru进行优化,采用了近似LRU进行缓存淘汰，可以参考<a href="https://zhuanlan.zhihu.com/p/34133067">https://zhuanlan.zhihu.com/p/34133067</a></p><p><strong>LFU[待补充]</strong></p><blockquote><p>LFU是对最近使用频率最小的节点进行淘汰的策略，一般使用hashMap和小根堆实现</p></blockquote><h1 id="redis使用姿势"><a href="#redis使用姿势" class="headerlink" title="redis使用姿势"></a>redis使用姿势</h1><p><a href="https://mp.weixin.qq.com/s/wT3i12HV_6ev5HSPJ9ANRg">高并发和海量数据下的 9 个 Redis 经典案例剖析！</a><br><a href="https://juejin.im/post/6844903859383451656">咆哮位图</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis基础知识&quot;&gt;&lt;a href=&quot;#redis基础知识&quot; class=&quot;headerlink&quot; title=&quot;redis基础知识&quot;&gt;&lt;/a&gt;redis基础知识&lt;/h1&gt;</summary>
    
    
    
    <category term="reids" scheme="https://stxl117.top/categories/reids/"/>
    
    
    <category term="reids" scheme="https://stxl117.top/tags/reids/"/>
    
  </entry>
  
  <entry>
    <title>2020面试小记</title>
    <link href="https://stxl117.top/2020/04/11/interview/"/>
    <id>https://stxl117.top/2020/04/11/interview/</id>
    <published>2020-04-11T10:41:32.000Z</published>
    <updated>2024-06-30T09:09:16.867Z</updated>
    
    <content type="html"><![CDATA[<p>写在即将入职之际，算是对这一次的换工作的一次总结吧。从去年年底下定决心换工作开始准备到现在，也过去了将近半年的时间了，最后斩获了自己比较满意的offer。与之前的几次换工作经历相比，这一次大致做了如下准备。</p><span id="more"></span><h2 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h2><h3 id="1-日常刷题"><a href="#1-日常刷题" class="headerlink" title="1.日常刷题"></a>1.日常刷题</h3><p>之前工作算是非典型的互联网工作，每天会在闲暇之余会在leetcode或者lintcode刷刷题，一开始刷题是为了开拓开拓思路，同时加强算法的掌握度。刷题时大概用过两种方式，第一种是按照某一类型进行从简单到难的专项加强，当然做到有些Medium难度和Hard难度的时候，会出现找不到突破点的挫败感，这时候不妨先休息一下，换换脑子刷一些水题，提升兴趣度和成就感；然后再回过头来从新思考之前没做出来的题，如果还没有想到解法，这时候就推荐参考一下大神们的解题思路，但是不要就抄一下AC就完事了，要看明白怎么解，去思考为什么，知道了思路再尝试自己去编码实现。</p><blockquote><p>不过说实话，难的问题感觉和天赋还是有关系的，到现在还是听到动态规划就望而却步</p></blockquote><h3 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2.基础知识"></a>2.基础知识</h3><p>这里可能要分为两部分，一部分是计算机相关的基础知识，一部分是常用语言相关的基础知识。</p><h4 id="计算机相关的基础知识"><a href="#计算机相关的基础知识" class="headerlink" title="计算机相关的基础知识"></a>计算机相关的基础知识</h4><p>像是数据结构和算法相关的可以再刷题中不断强化，比如说链表，数组，hash表等数据结构，是可以通过在刷题中，进一步掌握和熟练使用的；再就是一些网络相关的知识，比如说基本的TCP三次握手，四次挥手了解流程的同时，可以带入到日常的工作中，比如说四次挥手，每次求情间client和server的状态，未来在线上出现问题时，可以根据相关知识来判断问题可能出现的地方。</p><h4 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h4><p>之前是做java开发的，就只能根据相关的知识点进行准备，万变不离其宗吧。语言的特性，能解决的问题；常用框架和中间件的用法和原理，和对于平时工作中出现问题的分析和总结吧；再就是JVM。然后根据自身的情况进行着重的学习和查缺补漏。当然每次面试完进行复盘也是一个很好的查缺补漏的方式。<br>大体上觉得可以分为如下几个模块：<br>1.java基础类库的源码实现<br>2.工作中常用的框架和中间件的使用和原理<br>3.多线程并发实现方法<br><img src="http://image.stxl117.top/currency.jpg" alt="java并发编程.jpg"><br>4.JVM相关知识和调优思考<br><img src="http://image.stxl117.top/jvm.jpg" alt="JVM内存结构.jpg"><br>5.分布式相关问题—缓存和锁<br><img src="http://image.stxl117.top/cache.jpg" alt="缓存.jpg"><br><img src="http://image.stxl117.top/distrubte.jpg" alt="分布式.jpg"></p><blockquote><p>比如说我自身对于Spring的掌握就是一直停留在能用的基础上，对于其原理没有什么研究，这个在这次找工作的过程中其实吃了不少亏。到现在也没闹明白</p></blockquote><h3 id="3-设计相关"><a href="#3-设计相关" class="headerlink" title="3.设计相关"></a>3.设计相关</h3><p>功能设计和架构设计其实是建立在基础之上的东西，是把你工具箱中的东西进行整合和拔高的东西。但是说实话功能设计勉强算及格，但是架构层面的规划和设计，这方面的能力应该是未来一段时间需要着重去思考和提升的能力。从面试的角度来说比较常考察的点一方面是选型的问题，怎么在功能相似或相近的框架和中间件中选择最适合自己场景的;一方面就是功能开发中设计的能力，怎么做到单一职责原则，开闭原则，里氏替换原则等等，这里推荐大家可以看看领域驱动设计，然后在自身现在的项目区思考，如何在当前工作中去实践和改造。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/80921515">阿里技术专家详解DDD系列一</a><br><a href="https://yq.aliyun.com/articles/719251?spm=a2c4e.11153940.0.0.40f978d79VlL3H">阿里技术专家详解DDD系列二</a></p></blockquote><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h3><p>这里主要可能是一些基本的准备，比如说简历的书写（我也是渣渣，这里就不说了），自我介绍的准备，离职原因的表达等等；<br>还有就是觉得面试后的复盘也很重要，是很好的查缺补漏的方式。</p><h2 id="面试心态"><a href="#面试心态" class="headerlink" title="面试心态"></a>面试心态</h2><p>说到心态这件事，我本身就是一个心理素质不好的人，尤其是在面试一些自己很想去的公司的时候，往往会过于紧张，导致发挥失常。记得之前有一次面试过程中，面试官让介绍一下session和cookie，当时太紧张全程语无伦次，脑子里想的cookie说出来的却是session，面试结果可想而知。说实话面试心态的改变，主要来自去年开始进行面试官的工作，起初面试别人也会很紧张，但是在慢慢地面试过程中，对于面试有了新的理解。在现在的我看来，面试是面试官和面试者的一次技术探讨，面试过程中面试官其实是一个挖掘面试者的知识储备和思维能力的过程，而面试者则是在沟通过程中展示自己的技术能力和思考同时发现自身不足的过程；而最后的结果其实是一个相互匹配的结果。有这种观点以后，作为面试者在面试时的紧张情绪得到了很大的缓解。</p><h2 id="面试问题记录"><a href="#面试问题记录" class="headerlink" title="面试问题记录"></a>面试问题记录</h2><p>下面只是记录了现在还能记得起来的几个面试问题<br>1.https流程<br>2.限流处理<br>3.dubbo拓展传输协议<br>4.tcp三次握手和四次挥手<br>5.in not in exist索引<br>6.分布式一致性算法<br>7.spring循环依赖解决<br>8.线程池监控</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>准备换工作可以说是一个很好的对阶段性的知识进行总结和回顾的驱动因素，当然这不是我们唯一进步的驱动因素。技术是一个逐步积累的东西，不能指望一步登天，那相当于痴人说梦；在平时的工作中，应该从完成基本工作这个点为基础，思考怎么提升工作效能，提升代码质量，便于功能拓展，来更好的完成未来的工作，达到提升自我技术的诉求；对于设计要善于思考，首先对于跌倒过的坑，下次不能再跌倒，对于未来也要有一些前瞻性的思考，对于未来起量的情况下，怎么处理更方便的切换等等；后又一点是最近对于未来工作需要用到的技术和语言的学习时感受到的，在自己时间允许的情况下对于其他技术和语言进行学习，可以很好的拓宽思路，比如Node.js中的异步事件处理。</p><p>过年期间在家看了《奈非文化手册》，里边有几点觉得很是认同，首先公司当前需要的员工是当前能力可以和公司当前情况可以匹配的员工;同时对于面试这件事情，除了换工作也是对于自己在市场中价值的一次考验，让你能知道自己当前大概的市场价值是什么情况，同时也是一个了解当前大家使用的技术栈的方法（当然这里不是鼓励大家经常跳槽，稳定性很重要）。</p><blockquote><p>最后最后推荐大家多读读书，不光是技术书籍，别的方面的书籍也可以都有涉猎，对于思考会很有帮助。<br>推荐两个极客时间的课程<br><img src="http://image.stxl117.top/jike_1.jpg" alt="设计模式之美"><br><img src="http://image.stxl117.top/jike_2.jpg" alt="从0开始学架构"></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在即将入职之际，算是对这一次的换工作的一次总结吧。从去年年底下定决心换工作开始准备到现在，也过去了将近半年的时间了，最后斩获了自己比较满意的offer。与之前的几次换工作经历相比，这一次大致做了如下准备。&lt;/p&gt;</summary>
    
    
    
    <category term="other" scheme="https://stxl117.top/categories/other/"/>
    
    
    <category term="随笔" scheme="https://stxl117.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="https://stxl117.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记(四)——并发</title>
    <link href="https://stxl117.top/2020/03/18/go4/"/>
    <id>https://stxl117.top/2020/03/18/go4/</id>
    <published>2020-03-18T12:26:14.000Z</published>
    <updated>2024-06-30T09:09:16.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-goroutine"><a href="#1-goroutine" class="headerlink" title="1. goroutine"></a>1. goroutine</h1><h2 id="什么是goroutine"><a href="#什么是goroutine" class="headerlink" title="什么是goroutine"></a>什么是goroutine</h2><p><code>goroutine</code>是golang的最小执行单元，每个go程序至少会有一个主goroutine，这里可以类比成java中额主线程。为了更好的理解goroutine，可以将进程，线程和goroutine(其他语言中的协程)进行类比。</p><span id="more"></span><h2 id="进程，线程和goroutine"><a href="#进程，线程和goroutine" class="headerlink" title="进程，线程和goroutine"></a>进程，线程和goroutine</h2><p><img src="http://image.stxl117.top/ptcg.jpg" alt="进程，线程和协程关系"></p><p><strong>进程</strong>是操作系统进行资源分配，调度和执行的基本单元。当操作系统分配一个进程时，会生成一个唯一对应的PCB块以及为该进程分配专有的系统资源。后续操作系统的调度会通过对应的PCB块来进行。</p><p><strong>线程</strong>是程序执行流的最小单元，一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。一般情况下进程与线程为1:n的关系，同一个进程生成的线程会共享改进程的堆上资源。通常情况线程的调度由操作系统内核态进行调度。</p><p>**协程(goroutine)**是更轻量级的线程，或者可以理解为用户态的线程。协程的调度实现答题可以分为两种，一种是用户态的调度实现，比如python中有名的gevent，就是通过用户态调度器实现协程间的调度，这种调度方式存在的一个弊端是由于调度完全是在用户态进行的，所以内核线程与协程的映射关系为1:N,即一个线程内的协程都是交替执行，不能并发；而golang则是在此基础上进行了优化，采用两级调度模型，实现了协程的并发，所以goroutine和内核线程的对应关系为n:m。</p><blockquote><p>1.参考文章2中对于两级调度并发有更进一步的讲解<br>2.随着这两年互联网的发展，越来越多的语言开始对协程进行了支持，从最开始Python2的greenlet,gevent(线程和协程的对应关系为1:N,用户级线程模型)到Python3在语言层面进行了支持。java中也有kilim和Quasar进行了支持。</p></blockquote><h1 id="2-go关键字"><a href="#2-go关键字" class="headerlink" title="2. go关键字"></a>2. go关键字</h1><p><code>go</code>关键字是golang提供的生成和使用goroutine的关键字，如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;new goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> test()</span><br></pre></td></tr></table></figure><p><code>test</code>函数将在一个新建的goroutine中执行。由于golang在语言层面对于goroutine进行了支持，所以不用想在java中通过实现<code>Runnable</code>接口或者继承<code>Thread</code>后，还要显示的调用<code>start</code>方法才可以在新线程中执行相应的功能。同时由于goroutine的上下文切换开销和所需的内存空间更小(2k)，相同性能的机器可以支撑的goroutine数量远远多于可以支持的线程数量。</p><h1 id="3-chan关键字"><a href="#3-chan关键字" class="headerlink" title="3. chan关键字"></a>3. chan关键字</h1><p>golang将CSP模型作为其并发的基础。正如golang著名的口号一样：*”不要以共享内存的方式来通信，相反，要通过通信来共享内存”*。既然要用通信的方式来共享内存，所以go就有了channel的出现，来支持已通信的方式共享内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,n)</span><br><span class="line">channel &lt;- <span class="number">1</span> <span class="comment">//将信息写入channel</span></span><br><span class="line">i := &lt;-channel <span class="comment">//从channel中读取信息</span></span><br></pre></td></tr></table></figure><p>对于channel如何为golang的并发保驾护航，将在后面进行详细描述。</p><h1 id="4-select关键字"><a href="#4-select关键字" class="headerlink" title="4. select关键字"></a>4. select关键字</h1><p>第一次看到<code>select</code>这个关键字的时候，第一反应就是经典的select模型。对想的没错，golang中将通信过程中的通过<code>select</code>进行了语言层面支持了通信层面的多路复用器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">case</span> xxx:</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到golang中对于<code>select</code>的使用和前文中提到的<code>swtich</code>的关键字使用方法类似。</p><h1 id="5-go的内存模型"><a href="#5-go的内存模型" class="headerlink" title="5. go的内存模型"></a>5. go的内存模型</h1><p>类似于java中的JMM,go也通过定制内存模型，保证并发的正确性。类比于JMM中的happens-before原则，go中的happens-before原则如下，使用a<code>-&gt;</code>b标识a操作happens-before b操作。大体上go的内存模型可以分为以下几类</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>1.被引入包的init函数优先于本包的所有方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">import</span> q</span><br><span class="line"><span class="comment">//q.init -&gt; p.*</span></span><br></pre></td></tr></table></figure><p>2.导入的所有包的init函数-&gt;main函数的执行</p><h2 id="goroutine相关"><a href="#goroutine相关" class="headerlink" title="goroutine相关"></a>goroutine相关</h2><p>3.goroutine的创建 -&gt; 其执行</p><p>4.goroutine无法确保在程序中的任何事件发生之前退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> test()</span><br><span class="line">  fmt.Println(<span class="string">&quot;mian func&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test不一定能输出</span></span><br></pre></td></tr></table></figure><h2 id="channel管道"><a href="#channel管道" class="headerlink" title="channel管道"></a>channel管道</h2><p>5.一个goroutine向一个channel发送数据 -&gt;另一个goroutine从本channel中接收数据</p><p>6.当channel执行关闭操作后，channel中已有数据仍可被获取，获取完后，在进行获取则为零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果 0 1 2 3 4 0 0 0 0 0</span></span><br></pre></td></tr></table></figure><p>7.无缓存的channel的获取数据会阻塞到向channel中发送数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; ,<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;step one&quot;</span>)</span><br><span class="line">ch&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;step two&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以用无缓存的channel来实现锁机制</p></blockquote><p>8.对于一个容量为N的channel第k次接收数据 -&gt;该channel的第k+n次发送</p><blockquote><p>保证被消费，channel满了后会阻塞，直到有被消费调的信息，类比java中的BlockingQuene</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>又见CAS<br><code>sync</code>包提供了两种锁 :<code>sync.Mutex</code>和<code>sync.WRMutex</code><br> <code>sync.Mutex</code>独占锁<br> <code>sync.WRMutex</code>读写锁<br>类比Java中相应lock实现,区别go中锁不可重入</p></blockquote><p>9.对于任何 sync.Mutex 或 sync.RWMutex 类型的变量 l 以及 n &lt; m ，对 l.Unlock() 的第 n 次调用在对 l.Lock() 的第 m 次调用返回前发生。</p><p>10.对于任何 sync.RWMutex 类型的变量 l 对 l.RLock 的调用，存在一个这样的 n，使得 l.RLock 在对 l.Unlock 的第 n 次调用之后发生（返回），且与其相匹配的 l.RUnlock 在对 l.Lock的第 n+1 次调用之前发生。</p><h2 id="Once类型——单例好帮手"><a href="#Once类型——单例好帮手" class="headerlink" title="Once类型——单例好帮手"></a>Once类型——单例好帮手</h2><p>11.通过 once.Do(f) 对 f() 的单次调用在对任何其它的 once.Do(f) 调用返回之前发生（返回）。</p><blockquote><p>1.懒汉式在go中的最佳实践，思路同java中的线程安全的懒汉式单例<br>2.sync 包通过 Once 类型为存在多个Go程的初始化提供了安全的机制。 多个线程可为特定的 f 执行 once.Do(f)，但只有一个会运行 f()，而其它调用会一直阻塞，直到 f() 返回。</p></blockquote><h1 id="goroutine和channel随想"><a href="#goroutine和channel随想" class="headerlink" title="goroutine和channel随想"></a>goroutine和channel随想</h1><p>1.<a href="http://shouce.jb51.net/gopl-zh/ch9/ch9-07.html"> 示例: 并发的非阻塞缓存</a><br>2.java中可以通过ForkJoinPool来实现两级线程模型自定义调度器来实现可并发的java协程？</p><blockquote><p>e.g.1目录文件遍历和空间统计</p></blockquote><blockquote><p>参考内容：<br><a href="https://golang.org/ref/mem">go内存模型-en</a><br><a href="https://go-zh.org/ref/mem">go内存模型-zh</a><br><a href="https://juejin.im/entry/5b2878c7f265da5977596ae2">Goroutine并发调度模型深度解析&amp;手撸一个协程池</a><br><a href="https://juejin.im/post/5decff136fb9a016544bce67">深入理解golang之channel</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-goroutine&quot;&gt;&lt;a href=&quot;#1-goroutine&quot; class=&quot;headerlink&quot; title=&quot;1. goroutine&quot;&gt;&lt;/a&gt;1. goroutine&lt;/h1&gt;&lt;h2 id=&quot;什么是goroutine&quot;&gt;&lt;a href=&quot;#什么是goroutine&quot; class=&quot;headerlink&quot; title=&quot;什么是goroutine&quot;&gt;&lt;/a&gt;什么是goroutine&lt;/h2&gt;&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt;是golang的最小执行单元，每个go程序至少会有一个主goroutine，这里可以类比成java中额主线程。为了更好的理解goroutine，可以将进程，线程和goroutine(其他语言中的协程)进行类比。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>从lintcode LFU引发的思考</title>
    <link href="https://stxl117.top/2020/02/18/lfu/"/>
    <id>https://stxl117.top/2020/02/18/lfu/</id>
    <published>2020-02-18T13:56:34.000Z</published>
    <updated>2024-06-30T09:09:16.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目24-LFU-Cache"><a href="#题目24-LFU-Cache" class="headerlink" title="题目24. LFU Cache"></a>题目24. LFU Cache</h2><blockquote><p>LFU是一个著名的缓存算法<br>对于容量为k的缓存，如果缓存已满，并且需要逐出其中的密钥，则最少使用的密钥将被踢出。<br>实现LFU中的set 和 get操作</p></blockquote><p>题目的内容比较直观就是设计一个LFU缓存淘汰算法的实现，下面我们先来看下LFU的基本流程</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU算法中会记录一定时间内每个Key的被访问次数，淘汰时会淘汰最近一段时间内被访问次数最少的key,当多个keys计数值为最小值时，按照LRU进行淘汰,如下图所示：<br><img src="http://image.stxl117.top/lfu.png" alt="LFU示意"></p><span id="more"></span><h2 id="其他常见缓存淘汰策略"><a href="#其他常见缓存淘汰策略" class="headerlink" title="其他常见缓存淘汰策略"></a>其他常见缓存淘汰策略</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>FIFO是最简单的先进先出，使用Queue即可实现。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU是根据最近最少使用原则进行缓存淘汰的算法。顾名思义当需要进行页置换或者缓存淘汰时将最近最少命中的页或缓存剔除的算法，如下图：<br><img src="http://image.stxl117.top/lru.png" alt="LRU流程"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="HashMap-小根堆"><a href="#HashMap-小根堆" class="headerlink" title="HashMap + 小根堆"></a>HashMap + 小根堆</h3><p>时间复杂度 get : O(1)  set O(logk)<br>为了查询速度将缓存已key-value的形式保存在hashMap中，同时使用数组实现的小根堆来记录数据的访问频次情况，以便于淘汰策略进行淘汰操作。</p><blockquote><p><a href="https://github.com/skystmm/AlgorithmExercise/tree/master/src/main/java/com/skystmm/lintcode/cache">LFU解题代码</a></p></blockquote><h2 id="java中优先级队列PriorityQueue解析"><a href="#java中优先级队列PriorityQueue解析" class="headerlink" title="java中优先级队列PriorityQueue解析"></a>java中优先级队列PriorityQueue解析</h2><p><code>PriorityQueue</code>是一个无界的按照给定的比较方式进行小根堆排序的队列实现。</p><p><img src="http://image.stxl117.top/PQ.jpg" alt="PriorityQueue类关系"></p><p>从类图上我们可以看到，<code>PriorityQueue</code>的基础数据结构是<code>Object[]</code>，而通过<code>comparator</code>属性提供个性化的排序要求。由于上文中提到过<code>PriorityQueue</code>中是通过比较实现的小根堆。</p><blockquote><p>之后会把PriorityQueue简称为PQ</p></blockquote><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; pq = (PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = <span class="literal">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) c.comparator();</span><br><span class="line">    initFromPriorityQueue(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) c.comparator();</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PQ类提供了上面代码中的构造函数，从构造方法中，可以发现PQ中有两个比较重要的<code>capacity</code>和<code>comparator </code>属性（上文中已经提到过作用了）。capactity用来表示队列的容量，可以上面的代码中看到PQ的默认队列容量为DEFAULT_INITIAL_CAPACITY(11)，同时还提供了动态扩容的实现；对于通过已有其他Collection的实现类构造PQ队列时，基本可以分为两个步骤进行处理,首先将数据赋值给PQ的Object[]数组中，然后通过heapify方法对PQ Object[]数组的每个元素记性siftDown操作，来达到数据按照我们的约定的方式构建成相应的小根堆。</p><p>下面我们就来看看siftDown方法是怎么对已有数据进行堆排序的数据调整的,话不多说，代码先行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">         siftDownUsingComparator(k, x);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         siftDownComparable(k, x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">     Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;)x;</span><br><span class="line">     <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">     <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">         <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">             ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">             c = queue[child = right];</span><br><span class="line">         <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         queue[k] = c;</span><br><span class="line">         k = child;</span><br><span class="line">     &#125;</span><br><span class="line">     queue[k] = key;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>siftDown</code>方法接收两个参数，i为开始比较的位置，x为比较元素。上面没有把<code>siftDownUsingComparator</code>方法代码放上去，是因为两者的逻辑不同处仅在于比较上的不同，整体逻辑是一样的。由于PQ中的优先级排序方式采用的是小根堆的排序方式，可以看到<code>siftDownUsingComparator</code>主要操作是队列中的当前节点与其叶子节点的比较和交换操作。总体来说<code>siftDown</code>方法是对已有队列进行在排序的操作，在<code>removeAt</code>和<code>poll</code>被调用。</p><h3 id="2-插入元素"><a href="#2-插入元素" class="headerlink" title="2. 插入元素"></a>2. 插入元素</h3><p>Queue提供了<code>add</code>方法进行队列的入队操作，下面看看PQ中add的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> offer(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">         grow(i + <span class="number">1</span>);</span><br><span class="line">     size = i + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">         queue[<span class="number">0</span>] = e;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         siftUp(i, e);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> offer(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">         grow(i + <span class="number">1</span>);</span><br><span class="line">     size = i + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">         queue[<span class="number">0</span>] = e;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         siftUp(i, e);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，执行add操作流程可以看到，PQ中不接受null值。在入队前会先对队列容量进行判定，如果容量不足，将会触发扩容(<code>grow</code>方法)。扩容的代码这里就不放出来了。从插入第二个元素开始就会调用<code>siftUp</code>方法,来进行元素的堆排序操作（如下代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩容的操作中，当队列当前容量小于64时，扩容为容量的两倍，大于64时，扩容为当前容量的1.5倍，当容量超过<code>MAX_ARRAY_SIZE</code>的时候，会触发<code>hugeCapacity</code>进行扩容，如果需要的容量超过<code>MAX_INTEGER</code>会抛出oom异常，当所需容量大于<code>MAX_ARRAY_SIZE</code>时扩容为<code>MAX_INTEGER</code>。</p></blockquote><h3 id="PQ的总结"><a href="#PQ的总结" class="headerlink" title="PQ的总结"></a>PQ的总结</h3><p>总的来说PQ是一个基于小根堆排序方式实现的优先级队列， 队列中的第一个元素为当前排序方式中最小的元素，遍历结果并不是完全有序的（堆排序特点）。PQ中操作的时间复杂度<code>offer</code>,<code>add</code>,<code>poll</code>,<code>remove</code>为o(logn);<code>remove(item)</code>,<code>contain</code>操作为 o(n),<code>peek</code>,<code>获取某个元素</code>,<code>size</code>为o(1)。根据以上特点我们可以在按照优先级对任务进行分类执行时，使用PQ来进行任务的接收；当然LFU也可以使用PQ来实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目24-LFU-Cache&quot;&gt;&lt;a href=&quot;#题目24-LFU-Cache&quot; class=&quot;headerlink&quot; title=&quot;题目24. LFU Cache&quot;&gt;&lt;/a&gt;题目24. LFU Cache&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;LFU是一个著名的缓存算法&lt;br&gt;对于容量为k的缓存，如果缓存已满，并且需要逐出其中的密钥，则最少使用的密钥将被踢出。&lt;br&gt;实现LFU中的set 和 get操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目的内容比较直观就是设计一个LFU缓存淘汰算法的实现，下面我们先来看下LFU的基本流程&lt;/p&gt;
&lt;h3 id=&quot;LFU&quot;&gt;&lt;a href=&quot;#LFU&quot; class=&quot;headerlink&quot; title=&quot;LFU&quot;&gt;&lt;/a&gt;LFU&lt;/h3&gt;&lt;p&gt;LFU算法中会记录一定时间内每个Key的被访问次数，淘汰时会淘汰最近一段时间内被访问次数最少的key,当多个keys计数值为最小值时，按照LRU进行淘汰,如下图所示：&lt;br&gt;&lt;img src=&quot;http://image.stxl117.top/lfu.png&quot; alt=&quot;LFU示意&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="源码" scheme="https://stxl117.top/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="刷题" scheme="https://stxl117.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记(三)——语法</title>
    <link href="https://stxl117.top/2020/02/13/go3/"/>
    <id>https://stxl117.top/2020/02/13/go3/</id>
    <published>2020-02-13T12:10:30.000Z</published>
    <updated>2024-06-30T09:09:16.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.stxl117.top/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.jpg" alt="基础语法.jpg"></p><span id="more"></span><p><img src="https://image.stxl117.top/go%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="go预留关键字.png"></p><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><p>变量是每种语言都不可或缺的声明方式，go提供了以下几种声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;b&quot;</span></span><br><span class="line">a := <span class="string">&quot;c&quot;</span> <span class="comment">//只能在函数内使用</span></span><br><span class="line"><span class="keyword">var</span> a,b,c <span class="type">string</span> <span class="comment">//同类型多变量的声明</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在go语言中声明的变量如果在接下来作用域中不使用，编译时会报<strong>xxx declared and not used</strong>错</p></blockquote><p>除了上述几种声明，go语言还可用分组声明的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line"> a <span class="type">int</span> =<span class="number">1</span></span><br><span class="line"> b <span class="type">string</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时  go中还有一个特殊的变量，匿名变量(_)在表示接收但不会使用的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictValue := <span class="keyword">map</span>(<span class="type">string</span>)<span class="type">int</span>&#123;<span class="string">&quot;test&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">value,_ := dictValue[<span class="string">&quot;test&quot;</span>]</span><br></pre></td></tr></table></figure><p>当然除了上面的使用方式，匿名变量还有其他的作用，在稍后会做解释。</p><h2 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h2><p>常量可以是字符、字符串、布尔值或数值。不支持 推断赋值（:&#x3D;）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constValue <span class="type">int</span> =<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">black = <span class="number">0</span></span><br><span class="line">red = <span class="literal">iota</span></span><br><span class="line">_</span><br><span class="line">blue</span><br><span class="line">green =<span class="number">4</span></span><br><span class="line">organge,pink =<span class="literal">iota</span> ,<span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;black value: &quot;</span>,black)</span><br><span class="line">fmt.Println(<span class="string">&quot;red value: &quot;</span>,red)</span><br><span class="line">fmt.Println(<span class="string">&quot;blue value: &quot;</span>,blue)</span><br><span class="line">fmt.Println(<span class="string">&quot;green value: &quot;</span>,green)</span><br><span class="line">fmt.Println(<span class="string">&quot;organge value: &quot;</span>,organge)</span><br><span class="line">fmt.Println(<span class="string">&quot;pink value: &quot;</span>,pink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7504708-0f889ad2474c6f6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><p>从上面的代码中，可以看到常量也是支持分组定义和匿名变量的。还有一个很陌生的itoa。<br>iota代表了<strong>const声明块的行索引（下标从0开始）</strong>，还有就是我们看到_和blue并没有赋值，输出的时候结果blue输出的3，这里是const的特性<strong>第一个常量必须指定一个表达式，后续的常量如果没有表达式，则和上一行的表达式相同</strong>。</p><h2 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h2><p>除了go语言没有提供指针运算，其余和C语言中的指针一致——保存了值的内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>  <span class="comment">//零值为nil</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><blockquote><p>1.<code>&amp;</code> 操作符会生成一个指向其操作数的指针;<code>*</code>操作符表示指针指向的底层值。<br>2.由于go中函数都是值传递，所以经常使用指针传递的方式在函数中修改原有对象信息</p></blockquote><h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h2><h3 id="a-条件语句"><a href="#a-条件语句" class="headerlink" title="a.条件语句"></a>a.条件语句</h3><p>条件语句主要有<code>if...else...</code>和<code>switch</code>。<br><code>if...else...</code>语句和其他语言的没有什么区别，go中增加在if语句定义变量，该变量的作用域为<code>if...else</code>内</p><p><code>switch</code>语句，与其他语言最大的差异是，只会执行第一个命中<code>case</code>条件的程序段，不需要额外的<code>braek</code>跳出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;windows10.&quot;</span>)</span><br><span class="line"><span class="comment">//fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>fallthrough</strong>关键字可以使命中后的case继续执行</p></blockquote><h3 id="b-循环"><a href="#b-循环" class="headerlink" title="b.循环"></a>b.循环</h3><p>go中只有一种循环的写法<code>for</code> 语句，基本语法同java和python。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> &lt;初始化语句&gt;;&lt;条件语句&gt;;&lt;后置语句&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>break</code>和<code>continue</code>效果与其他语言一样，不做介绍</p></blockquote><blockquote><p>e.g. <a href="https://github.com/skystmm/learn-go/blob/master/exercise/loopandfunc/exercise-loops-and-func.go">for循环例子</a></p></blockquote><h2 id="5-包"><a href="#5-包" class="headerlink" title="5.包"></a>5.包</h2><p>go程序是由多个包构成的，其中每个可执行的go程序都是从main包开始的，main保重还需要有程序入口main函数，相当于java中的 <code>public static void main(String [] args)</code>方法和python中的<code>if __name__ == &quot;main &quot;</code>函数，关于go中的main函数会在函数中介绍。</p><p>go程序中引入包使用<code>import</code>关键字，和python，java中用法类似；同时go中import依然支持分组的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"> <span class="keyword">import</span> (</span><br><span class="line">    _  <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    . <span class="string">&quot;os&quot;</span></span><br><span class="line">    http <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面的代码中对于包的倒入有了几种不同方式，使用匿名(_)接包名导入的方式，表示导入该包，但是不可使用其导出方法，但会执行该包中的init方法；点操作是一种便捷方式，使用点操作导入的包，在使用其导出方法的的时候，可以不使用包名，直接使用导出的函数进行调用；最后<code>import http &quot;net/http&quot;</code>是给引入包起别名的一种方式，类似Python中的<code>import xxx as xx</code>。</p><blockquote><p>注意：<br>1.大写字母开头的变量和函数是可导出的，即其他包可以读取，是公用变量，公有函数；<br>2.小写字母开头的不可导出，是私有变量，私有函数。</p></blockquote><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><p>函数同java中的方法，python中的函数，声明如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> &lt;<span class="title">func_name</span>&gt;<span class="params">(param pramType ,...)</span></span>(result reusltType,...)&#123;</span><br><span class="line">    <span class="comment">//函数内部处理</span></span><br><span class="line">   <span class="comment">// 有返回值时</span></span><br><span class="line">   <span class="keyword">return</span> xxx,xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与java不同的是，go中的函数可以有多个返回值，同时生命时返回值在入参的后边（有点像scala的语法）。</p><blockquote><p>几个特殊的函数<br>main函数：go程序的入口函数，每个go包只能有1个或0个main函数<br>init函数：包导入的时候的初始化操作函数，有点像java中的构造函数<br>panic和revocer函数：go中的异常处理函数，类似 throw 和catch机制</p></blockquote><h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><p>在函数中可以使用defer关键字帮我们处理一些资源关闭和return前处理，defer的功能很像java中<code> finally</code>的处理，不同之处在于defer像一个栈一样，当程序即将运行完当前函数作用域时，会更具defer声明顺序的逆序一直执行defer的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Println(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> Println(<span class="string">&quot;six&quot;</span>)</span><br><span class="line">Println(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> Println(<span class="string">&quot;five&quot;</span>)</span><br><span class="line">Println(<span class="string">&quot;third&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> Println(<span class="string">&quot;four&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7504708-6419a0a64784ee09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行结果"></p><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p>闭包是一个函数值，它引用了其函数体之外的变量，该函数可以访问并赋予其引用的变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7.结构体"></a>7.结构体</h2><p>上次听到结构体这个名词还是在大一学c语言的时候，之后这个词的出镜率基本为0。go中的结构体声明和c异曲同工。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;structName&gt; <span class="keyword">struct</span> &#123;</span><br><span class="line">&lt;propertyName&gt; &lt;propertyType&gt;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在go结构体重有一种特殊的写法，如下代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">sex  <span class="type">bool</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">Human</span><br><span class="line">salary <span class="type">float32</span></span><br><span class="line">deaprt <span class="type">string</span></span><br><span class="line">age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">employee := Employee&#123;Human: Human&#123;name: <span class="string">&quot;Sky&quot;</span>, sex: <span class="literal">true</span>&#125;, salary: <span class="number">100.00</span>&#125;</span><br><span class="line">employee.age = <span class="number">30</span></span><br><span class="line">employee.Human.age = <span class="number">30</span></span><br><span class="line">employee.deaprt = <span class="string">&quot;go learn&quot;</span></span><br><span class="line">fmt.Println(employee)</span><br><span class="line"></span><br><span class="line">employee.name = <span class="string">&quot;Test&quot;</span></span><br><span class="line">fmt.Println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7504708-03dad36379f6c116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行结果"></p><p>上面代码中，声明了Human和Employee两个结构体，在Employee结构体通过匿名的方式引入了Human，这里可以理解成一种继承，当我们初始化Employee的变量employee 时，employee会拥有Human的所有属性；但是当父亲结构体和子结构体拥有相同的属性时，子结构体会覆盖服结构体的属性；如果需要修改父中的同名属性，如main函数第3行所示。<strong>go中可以通过结构体声明匿名的结构体属性，来实现继承。</strong></p><h2 id="8-方法（method）"><a href="#8-方法（method）" class="headerlink" title="8.方法（method）"></a>8.方法（method）</h2><p>方法就是一类带特殊的<em>接收者</em>参数的<strong>函数</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">sex  <span class="type">bool</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(human Human)</span></span> CheckSex() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> human.sex == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;男&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;女&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">boy := Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="literal">true</span>, <span class="number">30</span>&#125;</span><br><span class="line">girl := Human&#123;<span class="string">&quot;Luck&quot;</span>, <span class="literal">false</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Tom sex :&quot;</span>, boy.CheckSex())</span><br><span class="line">fmt.Println(<span class="string">&quot;Luck sex :&quot;</span>, girl.CheckSex())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-interface"><a href="#9-interface" class="headerlink" title="9.interface"></a>9.interface</h2><p>接口是由一组方法签名定义的集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;interfaceName&gt; <span class="keyword">interface</span> &#123;</span><br><span class="line">&lt;funcNmae&gt;( params)(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口也是值。它们可以像其它值一样传递。接口值可以用作函数的参数或返回值,保存了一个具体底层类型的具体值。</p><p>接口值调用方法时会执行其底层类型的同名方法。</p><blockquote><p><a href="https://github.com/skystmm/learn-go">文中代码实例</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.stxl117.top/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.jpg&quot; alt=&quot;基础语法.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记(二)——基本数据类型</title>
    <link href="https://stxl117.top/2020/02/11/go2/"/>
    <id>https://stxl117.top/2020/02/11/go2/</id>
    <published>2020-02-11T07:37:55.000Z</published>
    <updated>2024-06-30T09:09:16.862Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.stxl117.top/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" alt="Go语言.jpg"></p><span id="more"></span><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h2><p>go语言中的基本类型如上图所示，go语言中有五类基数类型。</p><h3 id="1）-boolean型"><a href="#1）-boolean型" class="headerlink" title="1） boolean型"></a>1） boolean型</h3><p>同其他语言一样，boolean包括两个值 true 和false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> booleanVal boolean = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-数值类型"><a href="#2-数值类型" class="headerlink" title="2)  数值类型"></a>2)  数值类型</h3><p>数值类型中可以分为三大类：整型，浮点型和复数</p><h4 id="a-整型"><a href="#a-整型" class="headerlink" title="a.整型"></a>a.整型</h4><p>go语言中直接定义好了不同位数的整型，其中包括如下表所示类型</p><table><thead><tr><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>rune</td><td>int32的别称</td></tr><tr><td>int8</td><td>8位带符号整数类型</td></tr><tr><td>int16</td><td>16位带符号整数类型</td></tr><tr><td>int32</td><td>32位带符号整数类型</td></tr><tr><td>int64</td><td>64位带符号整数类型</td></tr><tr><td>byte</td><td>相当于uint8别称</td></tr><tr><td>uint8</td><td>8位不带符号整数类型</td></tr><tr><td>uint16</td><td>16位不带符号整数类型</td></tr><tr><td>uint32</td><td>32位不带符号整数类型</td></tr><tr><td>uint64</td><td>64位不带符号整数类型</td></tr></tbody></table><blockquote><p>注意：<br>1.int的默认类型为int32<br>2.go语言中不支持隐式类型转换，哪怕是int8转int32，使用隐式类型转换会在编译器报错</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">//编译报错cannot use a (type int32) as type int8 in assignment</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int8</span> = a</span><br></pre></td></tr></table></figure><h4 id="b-浮点类型"><a href="#b-浮点类型" class="headerlink" title="b.浮点类型"></a>b.浮点类型</h4><p>浮点类型包括float32和float64两个，如果不显示声明为32位，则float默认为64位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatVal <span class="type">float64</span> =<span class="number">43.32</span></span><br></pre></td></tr></table></figure><h4 id="c-复数类型"><a href="#c-复数类型" class="headerlink" title="c.复数类型"></a>c.复数类型</h4><p>复数类型是go语言增加支持的数据类型，复数类型就是我们在高中数学中学过的复数，表示方法也和上学时学的表述方法一致。go语言依然为了兼容32位系统和64位系统，提供了两种复数基本类型complex128(64位实数和64位虚数,默认)和complex64(32位实数和32位虚数).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complexVal <span class="type">complex128</span> = <span class="number">58</span>+<span class="number">8i</span></span><br></pre></td></tr></table></figure><h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3) 字符串"></a>3) 字符串</h3><p>字符串类型的声明有两种方式双引号(“”)和反引号(&#96;&#96;)，两者的区别在于单引号可跨行，所见即所得，类似python中的三引号表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="keyword">var</span> ss <span class="type">string</span> =<span class="string">`a</span></span><br><span class="line"><span class="string"> b`</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(ss)</span><br></pre></td></tr></table></figure><blockquote><p>基础类型的零值：<br>数值类型为 0，<br>布尔类型为 false，<br>字符串为 “”（空字符串）。</p></blockquote><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>同其他语言差不多，区别在于声明是需要声明容量，声明后不可扩缩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int32</span></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line">b := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组声明中需要注意的是，数组容量的声明需要写在类型的前边，否则会报错。不像java中即可以写在前边也可以写在后边</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"> <span class="keyword">var</span> array <span class="type">int</span>[<span class="number">32</span>]</span><br></pre></td></tr></table></figure><h3 id="2-切片-slice"><a href="#2-切片-slice" class="headerlink" title="2. 切片(slice)"></a>2. 切片(slice)</h3><p>刚看到slice的时候，第一反应是python中的slice特性，两者有一些相似之处，也有不同之处。切片为数组元素提供动态大小的、灵活的视角,设计思想上python和go对于切片是一样的。区别在于python中slice更加灵活一些支持三个参数的切片处理（起止以及步长处理），而go中暂时支持起止处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//python实现</span></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">r = li[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]  <span class="comment">// [2,4]</span></span><br><span class="line"><span class="comment">//go实现</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//[2,3,4]</span></span><br></pre></td></tr></table></figure><p>go中的切片可以理解为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a [N]<span class="type">int</span></span><br><span class="line">        <span class="comment">//start end 为前必后开区间，同python</span></span><br><span class="line"><span class="keyword">var</span> start <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> end <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要注意的是如下情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">b := a[<span class="number">0</span>:]</span><br><span class="line">c := a[<span class="number">0</span>:]</span><br><span class="line"></span><br><span class="line">b[<span class="number">5</span>] = <span class="number">1</span></span><br><span class="line">fmt.Println(c[<span class="number">5</span>]) <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">7</span>)</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">fmt.Println(c[<span class="number">1</span>]) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>从上面代码的输出可以看到，在不发生扩容情况下，两个切片b和c底层都指向了数组a（地址引用），当我们修改切片b的index为5的数值后，切片c对应index结果也会改变。就像go指南中描述的一样，切片并不存储任何数据，它只是描述了底层数组中的一段。但是当我们向容量已满的切片b追加元素后，会触发扩容，扩容大致如下图，导致切片b的底层数组成了有变新的数组，所以在改变切片b的内数据后，切片c中数据不会发生改变。</p><p><img src="https://image.stxl117.top/slice%E6%89%A9%E5%AE%B9.jpg" alt="切片扩容"></p><blockquote><p>这里还需要注意的是，切片触发扩容规则如下：<br>1.切片每次新增个数不超过原来的1倍，且每次增加数不超过1024个，且增加后总长度小于1024个，这种情况下扩容后为原来的2倍<br>2.切片一次新增个数超过原来1倍，但不超过1024个，且增加后总长度小于1024个，这种情况下扩容后比实际具有的总长度还要大1<br>3.原切片长度超过1024时，一次增加容量不是2倍而是0.25倍，每次超过预定的都是0.25累乘,如果增加数量大于0.25增量，就是增加量+1</p></blockquote><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h3><p>采用哈希方式存储的数据类型，同java中的map,python中的字典。区别在于我们获取字典内数据值时，返回值有一些差异，如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dictDemo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;<span class="string">&quot;test&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//value为key对应的值，contain为boolean型，true为dictDemo包含key为test的键，false为不包含</span></span><br><span class="line">value,contain= dict[<span class="string">&quot;test&quot;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>参考内容：<br>1.<a href="https://tour.go-zh.org/">go语法指南</a><br>2. 《go web编程》</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.stxl117.top/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg&quot; alt=&quot;Go语言.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记(一)——环境搭建</title>
    <link href="https://stxl117.top/2020/02/07/go1/"/>
    <id>https://stxl117.top/2020/02/07/go1/</id>
    <published>2020-02-07T14:34:17.000Z</published>
    <updated>2024-06-30T09:09:16.861Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.stxl117.top/Go%E8%AF%AD%E8%A8%80.jpg" alt="Go语言.jpg"></p><span id="more"></span><h1 id="go安装和配置"><a href="#go安装和配置" class="headerlink" title="go安装和配置"></a>go安装和配置</h1><p><a href="https://studygolang.com/dl">国内源下载</a></p><p>windows环境下，下一步安装法，即可完成安装</p><blockquote><p><a href="https://go-zh.org/doc/">go中文文档</a><br>  <a href="https://golang.google.cn/pkg/">go包信息检索</a></p></blockquote><h1 id="go的常用命令"><a href="#go的常用命令" class="headerlink" title="go的常用命令"></a>go的常用命令</h1><p>go包含的命令 如下图：<br><img src="https://image.stxl117.top/7504708-46eb42f7e559ecec.png" alt="go命令.png"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>可选参数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>go build</td><td>-o 指定输出名称</td><td>将go代码文件编译成可执行文件</td><td>默认输出名称为package名称，使用build时，会忽略已”_”和”.”开头的文件</td></tr><tr><td>go install</td><td></td><td></td><td></td></tr><tr><td>go clean</td><td></td><td>清理当前项目中的</td><td></td></tr><tr><td>go get</td><td></td><td>从远程仓库获取代码包</td><td>同python的pip</td></tr><tr><td>go fmt</td><td>-w 写入到源文件</td><td>代码标准格式化</td><td></td></tr><tr><td>go test</td><td></td><td>执行单元测试(文件名为*_test.go)</td><td></td></tr></tbody></table><h1 id="IDE选择"><a href="#IDE选择" class="headerlink" title="IDE选择"></a>IDE选择</h1><h2 id="1-atom"><a href="#1-atom" class="headerlink" title="1.atom"></a>1.atom</h2><p><a href="https://blog.csdn.net/sweetvvck/article/details/50333327">在atom上开发go</a></p><h2 id="2-vs-code"><a href="#2-vs-code" class="headerlink" title="2. vs code"></a>2. vs code</h2><p>安装请至<a href="https://code.visualstudio.com/Download">官网</a>选择对应版本进行安装</p><blockquote><p><a href="https://www.jianshu.com/p/3171be60b736">vscode实用快捷键</a></p></blockquote><h3 id="手动安装go需要的插件"><a href="#手动安装go需要的插件" class="headerlink" title="手动安装go需要的插件"></a>手动安装go需要的插件</h3><blockquote><p><a href="https://blog.csdn.net/dmt742055597/article/details/85865186">vs code go插件安装失败问题解决</a></p></blockquote><h4 id="创建github-com下的插件"><a href="#创建github-com下的插件" class="headerlink" title="创建github.com下的插件"></a>创建github.com下的插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span><br><span class="line"><span class="built_in">mkdir</span> github.com</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com</span><br><span class="line"><span class="built_in">mkdir</span> acroca cweill derekparker go-delve josharian karrick mdempsky pkg ramya-rao-a rogpeppe sqs uudashr</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/acroca</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/acroca/go-symbols.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/cweill</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cweill/gotests.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/derekparker</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/derekparker/delve.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/go-delve</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/go-delve\delve.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/josharian</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/josharian/impl.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/karrick</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/karrick/godirwalk.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/mdempsky</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mdempsky/gocode.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/pkg</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pkg/errors.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/ramya-rao-a</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ramya-rao-a/go-outline.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/rogpeppe</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rogpeppe/godef.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/sqs</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sqs/goreturns.git</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/uudashr</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/uudashr/gopkgs.git</span><br></pre></td></tr></table></figure><h4 id="创建golang-org下的插件"><a href="#创建golang-org下的插件" class="headerlink" title="创建golang.org下的插件"></a>创建golang.org下的插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span><br><span class="line"><span class="built_in">mkdir</span> -p golang.org/x</span><br><span class="line"><span class="built_in">cd</span> golang.org/x</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/lint.git</span><br></pre></td></tr></table></figure><h4 id="手动安装插件"><a href="#手动安装插件" class="headerlink" title="手动安装插件"></a>手动安装插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span><br><span class="line">go install github.com/mdempsky/gocode</span><br><span class="line">go install github.com/uudashr/gopkgs/cmd/gopkgs</span><br><span class="line">go install github.com/ramya-rao-a/go-outline</span><br><span class="line">go install github.com/acroca/go-symbols</span><br><span class="line">go install github.com/rogpeppe/godef</span><br><span class="line">go install github.com/sqs/goreturns</span><br><span class="line">go install github.com/derekparker/delve/cmd/dlv</span><br><span class="line">go install github.com/cweill/gotests</span><br><span class="line">go install github.com/josharian/impl</span><br><span class="line">go install golang.org/x/tools/cmd/guru</span><br><span class="line">go install golang.org/x/tools/cmd/gorename</span><br><span class="line">go install golang.org/x/lint/golint</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.stxl117.top/Go%E8%AF%AD%E8%A8%80.jpg&quot; alt=&quot;Go语言.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://stxl117.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://stxl117.top/tags/golang/"/>
    
    <category term="环境搭建" scheme="https://stxl117.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab搭建和基本操作</title>
    <link href="https://stxl117.top/2020/01/14/build-gitlab/"/>
    <id>https://stxl117.top/2020/01/14/build-gitlab/</id>
    <published>2020-01-14T14:34:20.000Z</published>
    <updated>2024-06-30T09:09:16.857Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期工作的原因，项目中引入了gitlab作为规则引擎中规则版本进行管理，所以需要搭建gitlab，故记录下搭建过程已备以后查看。</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>本文是在centOS7 64环境下进行安装，gitlab安装版本为CE-9.5.9，使用官网下载的rpm包进行安(<a href="https://packages.gitlab.com/gitlab/gitlab-ce">官网下载链接</a>)</p><blockquote><p>注意：gitlab对硬件至少4GB内存</p></blockquote><span id="more"></span><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># yum install -y curl policycoreutils-python openssh-server</span></span><br><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># systemctl enable sshd</span></span><br><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># systemctl start sshd</span></span><br><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># firewall-cmd --permanent --add-service=http</span></span><br><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># systemctl reload firewalld</span></span><br><span class="line"><span class="meta">##修改/etc/sysconfig/selinux 永久生效</span></span><br><span class="line">setenforce <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="gitlab安装"><a href="#gitlab安装" class="headerlink" title="gitlab安装"></a>gitlab安装</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># rpm -ivh gitlab-ce-9.5.9-ce.0.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure><h2 id="2-基础配置修改"><a href="#2-基础配置修改" class="headerlink" title="2.基础配置修改"></a>2.基础配置修改</h2><p>配置文件尾 &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta"># vim  /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="meta">#进入配置文件后</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#对gitlab访问域名进行配置，可以为ip</span></span><br><span class="line">external_url <span class="string">&#x27;http://&lt;gitlab访问的域名&gt;:10000&#x27;</span></span><br><span class="line"><span class="meta">#修改nginx的端口，默认为80，这里修改后external_url需要进行同步修改</span></span><br><span class="line">nginx[<span class="string">&#x27;listen_port&#x27;</span>] = <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>完成修改后需要执行</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta">#  gitlab-ctl reconfigure</span></span><br></pre></td></tr></table></figure><p>使修改生效</p><h3 id="gitlab常用命令"><a href="#gitlab常用命令" class="headerlink" title="gitlab常用命令"></a>gitlab常用命令</h3><blockquote><p>p.s.启停等命令需要在root权限下执行，否则会出现access deny错误提示，导致无法启动问题</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl <span class="literal">start</span> <span class="comment">#启动全部服务</span></span><br><span class="line">gitlab-ctl restart <span class="comment">#重启全部服务</span></span><br><span class="line">gitlab-ctl <span class="literal">stop</span> <span class="comment">#停止全部服务</span></span><br><span class="line">gitlab-ctl restart nginx <span class="comment">#重启单个服务</span></span><br><span class="line">gitlab-ctl status <span class="comment">#查看全部组件的状态</span></span><br><span class="line">gitlab-ctl show-config <span class="comment">#验证配置文件</span></span><br><span class="line">gitlab-ctl uninstall <span class="comment">#删除gitlab(保留数据）</span></span><br><span class="line">gitlab-ctl cleanse <span class="comment">#删除所有数据，重新开始</span></span><br><span class="line">gitlab-ctl tail <span class="tag">&lt;svc_name&gt;</span>  <span class="comment">#查看服务的日志</span></span><br><span class="line">gitlab-rails console production <span class="comment">#进入控制台 ，可以修改root 的密码</span></span><br></pre></td></tr></table></figure><h2 id="3-root密码修改"><a href="#3-root密码修改" class="headerlink" title="3.root密码修改"></a>3.root密码修改</h2><p>gitlab安装完毕后，使用浏览器第一次访问gitlab时，可以对root账号进行密码修改</p><p>对root账号密码进行修改，还可以使用命令行进行，具体命令如下</p><h3 id="1）在系统root权限下执行"><a href="#1）在系统root权限下执行" class="headerlink" title="1）在系统root权限下执行"></a>1）在系统root权限下执行</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server ~]<span class="meta">#  gitlab-rails console production</span></span><br></pre></td></tr></table></figure><h3 id="2）进入rails-console后进行如下操作"><a href="#2）进入rails-console后进行如下操作" class="headerlink" title="2）进入rails console后进行如下操作"></a>2）进入rails console后进行如下操作</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">irb(main)<span class="symbol">:001</span><span class="symbol">:0</span>&gt; user = User.where(<span class="symbol">id:</span> <span class="number">1</span>).first</span><br><span class="line">=&gt; #&lt;User <span class="symbol">id:1</span> @root&gt;</span><br><span class="line"></span><br><span class="line">irb(main)<span class="symbol">:002</span><span class="symbol">:0</span>&gt; user.password=<span class="string">&quot;12345678&quot;</span></span><br><span class="line">=&gt; <span class="string">&quot;12345678&quot;</span></span><br><span class="line"></span><br><span class="line">irb(main)<span class="symbol">:003</span><span class="symbol">:0</span>&gt; user.password_confirmation=<span class="string">&quot;12345678&quot;</span></span><br><span class="line">=&gt; <span class="string">&quot;12345678&quot;</span></span><br><span class="line"></span><br><span class="line">irb(main)<span class="symbol">:004</span><span class="symbol">:0</span>&gt; user.save!</span><br><span class="line">=&gt; <span class="built_in">true</span></span><br><span class="line"></span><br><span class="line">irb(main)<span class="symbol">:005</span><span class="symbol">:0</span>&gt; quit</span><br></pre></td></tr></table></figure><p>即可对gitlab的root账户进行密码修改</p><h2 id="3-gitlab数据备份和恢复"><a href="#3-gitlab数据备份和恢复" class="headerlink" title="3.gitlab数据备份和恢复"></a>3.gitlab数据备份和恢复</h2><h3 id="1）对gitlab进行定时备份任务配置"><a href="#1）对gitlab进行定时备份任务配置" class="headerlink" title="1）对gitlab进行定时备份任务配置"></a>1）对gitlab进行定时备份任务配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@your-server ~]<span class="comment"># vim  /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="comment">#进入配置文件后</span></span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">&#x27;manage_backup_path&#x27;</span>] = true</span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_path&#x27;</span>] = <span class="string">&quot;/data/gitlab/backups&quot;</span>    <span class="regexp">//gi</span>tlab备份目录，不配置时，默认为<span class="regexp">/var/</span>opt<span class="regexp">/gitlab/</span>backup目录</span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_archive_permissions&#x27;</span>] = <span class="number">0644</span>       <span class="regexp">//</span>生成的备份文件权限</span><br><span class="line">gitlab_rails[<span class="string">&#x27;backup_keep_time&#x27;</span>] = <span class="number">7776000</span>              <span class="regexp">//</span>备份保留天数为<span class="number">3</span>个月（即<span class="number">90</span>天，这里是<span class="number">7776000</span>秒）</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果修改了backup_path，需要确保配置的路径存在和权限正确，进行如下配置</span></span><br><span class="line">[root@your-server ~]<span class="comment"># mkdir -p /data/gitlab/backups</span></span><br><span class="line">[root@your-server ~]<span class="comment"># chown -R git.git /data/gitlab/backups</span></span><br><span class="line">[root@your-server ~]<span class="comment"># chmod -R 777 /data/gitlab/backups</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使配置修改生效</span></span><br><span class="line">[root@your-server ~]<span class="comment"># gitlab-ctl reconfigure</span></span><br></pre></td></tr></table></figure><h3 id="2）手动备份gitlab"><a href="#2）手动备份gitlab" class="headerlink" title="2）手动备份gitlab"></a>2）手动备份gitlab</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@code</span>-server backups]<span class="meta"># gitlab-rake gitlab:backup:create</span></span><br></pre></td></tr></table></figure><p>执行完成后，会在gitlab的backup_path下生成备份的tar文件，这里也可以利用linux的crontab来配置定时任务进行备份。</p><h3 id="3）gitlab恢复"><a href="#3）gitlab恢复" class="headerlink" title="3）gitlab恢复"></a>3）gitlab恢复</h3><p>首先关闭gitlab数据相关服务</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server backups]<span class="meta"># gitlab-ctl stop unicorn</span></span><br><span class="line">[root<span class="symbol">@your</span>-server backups]<span class="meta"># gitlab-ctl stop sidekiq</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#查看gitlab运行状态，确保unicorn，sidekiq两个服务已经停止</span></span><br><span class="line">[root<span class="symbol">@your</span>-server backups]<span class="meta"># gitlab-ctl status</span></span><br></pre></td></tr></table></figure><p>然后将备份文件拷贝到gitlab配置的backup_path路径下（默认为&#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;backups目录）</p><p>然后执行gitlab恢复命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如导出的备份文件为1578453712_2020_01_08_9.5.9_gitlab_backup.tar，则备份信息版本号为1578453712_2020_01_08_9.5.9</span></span><br><span class="line">gitlab-rake gitlab:backup:restore <span class="attribute">BACKUP</span>=&lt;备份信息版本号&gt;</span><br><span class="line">根据恢复提示信息进行<span class="literal">yes</span>操作，即可完成gitlab的恢复工作</span><br></pre></td></tr></table></figure><p>最后重新启动gitlab即可完成恢复工作</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@your</span>-server backups]<span class="meta"># gitlab-ctl start</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于近期工作的原因，项目中引入了gitlab作为规则引擎中规则版本进行管理，所以需要搭建gitlab，故记录下搭建过程已备以后查看。&lt;/p&gt;
&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;本文是在centOS7 64环境下进行安装，gitlab安装版本为CE-9.5.9，使用官网下载的rpm包进行安(&lt;a href=&quot;https://packages.gitlab.com/gitlab/gitlab-ce&quot;&gt;官网下载链接&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：gitlab对硬件至少4GB内存&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="git" scheme="https://stxl117.top/categories/git/"/>
    
    
    <category term="git" scheme="https://stxl117.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2019再见2020你好</title>
    <link href="https://stxl117.top/2020/01/10/summary2019-md/"/>
    <id>https://stxl117.top/2020/01/10/summary2019-md/</id>
    <published>2020-01-10T13:54:33.000Z</published>
    <updated>2024-06-30T09:09:16.875Z</updated>
    
    <content type="html"><![CDATA[<p>在罗同学的推荐下，看了《拍出绝世光线：摄影师的完美用光技巧解密》一书，看书的过程中觉得自己打通了任督二脉，可是实践后。。。然后千辛万苦挑出来了上面两张照片，当然也要感谢罗同学的友情配合，还有对于我这令人发指的人像水平的包容，以及孜孜不倦的鼓励。虽然依然没什么进步，但是还是要在这立个Flag——2020至少能拍出能看的人像吧。</p><span id="more"></span><p> <img src="https://upload-images.jianshu.io/upload_images/7504708-fca6136f9b9e0c63.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1月.爱读书的罗同学.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-f330d679911f166e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1月.被摆拍.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-1449ef0bbabd72af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2月.烟雨西湖.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-e5bb333acfae781c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2月.西湖雾影.jpg"></p><p>都说晴西湖不如雨西湖，雨西湖不如雾西湖。西湖改变了之前我对阴天雨天的态度，之前一到阴雨天只想待在家中，享受被窝和睡眠，而看到了烟雨中的西湖却是另一番风味。当然能领略这不一样的西湖还有一个很大的原因，杭州的雨真的是多。稍显夸张的说杭州一年下雨的天数，感觉可以比得上兰州十年的下雨的天数了。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-abfa68955ba88946.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5月.箱根.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-af514b7a65f58a7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5月.日枝神社.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-e9ab79ce1fc1c093.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5月.信仰打卡.jpg"></p><p>五一罗同学和我密谋了我们的honeymoon,当然也是罗同学带着我第一次走出了国门，当时的我那叫一个紧张，当然也有那么一点小兴奋。我们的第一次共同出国旅行，选择了相对难度不大的日本。当然日本的铁路交通还是给我们好好地上了一课，出门做错地铁做过站成了日常。印象最深的是我们在镰仓的时候，在镰仓社区中找到了一家很幽静的餐厅吃饭，老板是一对中年夫妻，他们不会中文，和我们一样只会蹩脚的英语，沟通都有点困难，但是这一餐给我的感觉却是最不一样的。</p><blockquote><p>友情提示: 去镰仓打卡灌篮高手，出了一出车站的路口，沿着海边往前走一点，还有个几乎一摸一样的路口，那里基本就没有什么游客拍照了，可以尽情的打卡。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7504708-df9dfe4dcaa6ba67.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7月.夏之荷.jpg"></p><p>小区里的荷花，住了第二年终于是拍到了，之前总是在上班路上看到，到了周末就宅宅宅的错过花期。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-cccf2a82a16df1a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8月.台风后的聚贤亭.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-4a46f245046f2af0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8月.聚贤亭·夜.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-65f00789bd4eb385.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8月.雷峰塔·夜.jpg"></p><p>哈哈哈，终于把聚贤亭四季和夜景凑齐了，之前的春秋冬，加上今年的夏日台风过后和夜景，算是完成了去年立下的一个flag。再附赠一张雷峰塔吧，不过还是要吐槽下自己，有一次没有带脚架，只能找台子，然后这树叶就没得办法了。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-347a3f37461030c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8月.忽地笑.jpg"></p><p>一直以为这是彼岸花，结果用识花小程序一扫，才知道黄色的叫忽地笑，红色和白色的才是彼岸花。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-10c7844189bede22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9月.滨江灯光秀.jpg"></p><p>又又又没带脚架，幸好滨江江边跑道的护栏给力，才能靠着护栏拍出来。说起来约饭后遛弯，刚好碰上了灯光秀，运气是满满的</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-057b44a0d49d457d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9月.满陇桂雨.jpg"></p><p>慕名而来的满陇桂雨，竟然是传说中儿童公园。最喜欢的就是杭州的九月底十月初，不经意的呼吸中会有香甜的桂花香，吸入鼻腔是很幸福的体验。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-720793261e0fe303.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9月.引客松.jpg"></p><p>大学同学相识十年聚会，终于不在武汉，返到来了一次黄山行。为了爬山提前开始跑步，锻炼身体。然后很好的印证的减肥就是管住嘴，迈开腿的说法。不过黄山归来，运动没能坚持，结果体重再一次到了新高。。。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-15444dd32c8a3657.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9月.角落君.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-2f76114591dae0dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9月.香克斯.jpg"></p><p>小痰盂的初次使用，拍拍家里的小摆件。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-268a1994eace289b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.北回归线.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-cdadd7fc4fb4e889.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.博朗大道.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-c5933ff1f3e52c7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.多良车站.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-3a1e06bab71fb244.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.高雄love观景台.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-4ad3461e88f29e97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.七星潭.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-266b98452c9d73d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.垦丁夕阳.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-e1125a544a39da4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.垦丁夕阳.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-40cf7a6d62a1bd6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.环岛梦.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-e5009d3308c2cfd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10月.瑞穗农场.jpg"></p><p>和罗同学2019的第二次出行，台湾一个我心心念念的地方，不知道为什么总觉得去过了台湾，才算是有机会看遍祖国的大好山河。这次行程是我们从日本回来不久就开始筹划的，也正因为筹划的早才得以成行。可以说是真的运气好。十一长假没有了人山人海，比肩接踵的人流；有的是刚刚好的旅人，和形形色色的当地美食。如果你有个机车梦，一定要去台湾；如果你是个老饕，也一定要来台湾；如果你喜欢历史鼓动，台湾也是很好的选择。</p><p>在花莲碰到了台风，虽然当天只能冒雨随便走走，但是也要感谢台风天，没有台风天就不会有这么多碧天晴空。虽然因为台风，没能去成太鲁阁，但是却和太鲁族的原著民一起了解了他们的风土人情，失之桑榆收之东隅大抵如此吧。如有有机会希望可以和两三好友一起，一人一车一起再次环岛。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-7a371e3ba5a14844.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12月.白塔枫叶.jpg"></p><p>12月的杭城，还是一片晚秋的景色。家门口不经意间还有一抹桂花香，银杏也是刚刚才落了地，腊梅还没有来，红叶却是布满了山涧。暖阳午后一抹红叶，一缕斜阳。杭城的四季都是这么的诗情画意。</p><p>2019就这样结束了，人生的31年也开始了。终于不在口头上抵触30了，反正都已经31了。2020还是要继续努力呀。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-911d55e9700d5351.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="彩蛋.jpg"><br>最后附上罗同学2019大作一张。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在罗同学的推荐下，看了《拍出绝世光线：摄影师的完美用光技巧解密》一书，看书的过程中觉得自己打通了任督二脉，可是实践后。。。然后千辛万苦挑出来了上面两张照片，当然也要感谢罗同学的友情配合，还有对于我这令人发指的人像水平的包容，以及孜孜不倦的鼓励。虽然依然没什么进步，但是还是要在这立个Flag——2020至少能拍出能看的人像吧。&lt;/p&gt;</summary>
    
    
    
    <category term="年度总结" scheme="https://stxl117.top/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://stxl117.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年度总结" scheme="https://stxl117.top/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>第五届天池中间件比赛初赛总结</title>
    <link href="https://stxl117.top/2019/07/28/tianchi/"/>
    <id>https://stxl117.top/2019/07/28/tianchi/</id>
    <published>2019-07-28T09:38:47.000Z</published>
    <updated>2024-06-30T09:09:16.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>了解到天池程序设计大赛还是去年在网上逛博客的时候，看到有人分享了自己的参赛经历，和在参赛过程中一步步完善思路提高成绩的过程（<a href="https://juejin.im/post/5c471e3d6fb9a04a0822031a">附上链接</a>）。就暗暗记下了这个比赛想要有朝一日自己也亲自操刀尝试一下。</p><span id="more"></span><h1 id="赛题——自适应负载均衡的设计实现"><a href="#赛题——自适应负载均衡的设计实现" class="headerlink" title="赛题——自适应负载均衡的设计实现"></a>赛题——自适应负载均衡的设计实现</h1><p><img src="https://upload-images.jianshu.io/upload_images/7504708-db89a511d4ccae8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>题目的内容是基于Dubbo的负载均衡算法实现，如上图所示，测评时提供三个配置和性能不同的provider节点。同时可以通过官方提供的辅助接口进行想过性能数据的采集。</p><p>可以通过provider的Callback获取provider的基本信息，包括最大线程数，内存使用信息等；提供了comsumer和provider端的Fliter可以进行请求情况的采集；provider端还提供了限流器TestRequestLimiter 来进行限流操作。</p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><p>本次和队友各设计实现了一种负载均衡算法，答题思路都是通过固定时间窗口进行统计，根据统计值进行权重计算，来更新下一轮次的权重，同时根据权重选择节点采用了平滑加权轮训算法，来保证请求分配按照权重比例进行分配。算法一采用统计成功次数占比的方式来计算下个周期的权重，算法二采用统计平均rt的方式，在计算下一周期的各个节点的分配权重。整体流程如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-8f2f2d0f3e6743b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tianchi_st.jpg"></p><h1 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h1><h2 id="引入平滑加权轮询算法"><a href="#引入平滑加权轮询算法" class="headerlink" title="引入平滑加权轮询算法"></a>引入平滑加权轮询算法</h2><p>接下来主要说一说成功占比这一实现的优化过程，起初版本大概在113W左右徘徊。这个版本对于节点的选择，是通过生成一个随机数，然后看随机数落在哪个节点区间，进行随机节点选择。这种方式会有很大的随机性，导致出现15-20%的限流请求。后来和队友讨论，将随机选择算法换成了平滑加权轮询算法，来进行节点的选择，跟换算法后，错误请求数大幅下降，基本达到了99.99的成功率。成绩也有了大幅提升，大概来到了117W左右。</p><h2 id="引入rt和并发量统计"><a href="#引入rt和并发量统计" class="headerlink" title="引入rt和并发量统计"></a>引入rt和并发量统计</h2><p>由于最大并发是1024而三个节点的总线程数为1300(200+450+650),所以会出现全部测评过程中权重不发生任何变化的情况。就想到了根据统计固定窗口期的rt来进行权重便宜调整，但是计算出周期内平均rt并不能很好的和当前使用的权重进行关联，后来通过rt计算出本窗口期的最大并发，在结合题目中每个周期内每节点最大并发数变化的。根军统计结果计算出本窗口期的并发量，然后根据情况修改权重。修改完成的版本成绩有了一定提升，当然也和赛会方提高了上限乏味有一定关系，这一阶段成绩在122-125W之间浮动，浮动区间比较大。</p><h2 id="乱七八糟的参数调优"><a href="#乱七八糟的参数调优" class="headerlink" title="乱七八糟的参数调优"></a>乱七八糟的参数调优</h2><p>进一步优化就是修改部分参数，同时部分区间的rt偏大的情况，引入了根据rt情况微调权重的计算逻辑，但是这部分的优化并没有带来成绩的提升，但是增加了成绩的稳定性，成绩基本稳定在124-125W之间，这也是最后的成绩。未能突破初赛，赛后在进行总结，准备明年再战。</p><h1 id="未能提交的思路"><a href="#未能提交的思路" class="headerlink" title="未能提交的思路"></a>未能提交的思路</h1><p>昨天晚上临睡前在突然想到一种新的方式来进行负载均衡，大体的思路是根据provider的请求数和其最大线程数进行统计计算权重，摒弃之前使用的固定时间窗口统计的方式，改为实时统计。大体流程为在consumer的filter每次invoke前生成一条消息，对应invoker的权重-1，在response中如果成功，则对应invoker的权重+1，如果有异常则对应invoker的权重置为0。</p><p>但是由于错看了截止时间，想要今天在实现，当实现了最初版的时候，发现初赛提交已经结束，所以这个思路的结果不得而知。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>刚刚群里有排名靠前的大佬公开了初赛代码，学习了下他们的思路和代码，发现差距还是比较大的。接下来好好学习，多看多想，来年再战。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h1&gt;&lt;p&gt;了解到天池程序设计大赛还是去年在网上逛博客的时候，看到有人分享了自己的参赛经历，和在参赛过程中一步步完善思路提高成绩的过程（&lt;a href=&quot;https://juejin.im/post/5c471e3d6fb9a04a0822031a&quot;&gt;附上链接&lt;/a&gt;）。就暗暗记下了这个比赛想要有朝一日自己也亲自操刀尝试一下。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="比赛" scheme="https://stxl117.top/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>人人网好友关系爬取</title>
    <link href="https://stxl117.top/2019/03/11/renren-md/"/>
    <id>https://stxl117.top/2019/03/11/renren-md/</id>
    <published>2019-03-11T14:07:36.000Z</published>
    <updated>2024-06-30T09:09:16.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一开始准备爬取人人网的数据，是因为想把自己的人人数据做一个备份，结果后来就跑偏了，成了爬取好友关系网。（p.s.再一次成功跑偏）。作为拖延症重度患者，本来这个爬虫是在人人网被转卖的时候写好的，但是仅仅是把数据爬了回来，让数据安静的躺在家里的树莓派里。</p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>要爬去一个网站的数据，首先是要对这个网站及这个网站中想要获取数据的数据接口进行分析。不同于上次大麦网（资讯类网站）数据的获取，这里解决需要用户的登录以及session保存的问题。<br>人人网作为曾经风靡一时的社交类网站，对于登录认证还是做了一些加固的，不像有些网站明文密码传输。而是对于密码信息进行了加密处理。正好前一段时间尝试爬取一些漫画类网站的时候，有看到使用selenium+phantomjs模拟浏览行为的方式，获取动态加载的漫画图片。也是出于偷懒的心思，就决定试试用selenium+phantomjs来绕过人人网的登录。</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>决定了使用seleium+phantomjs来作为这次爬虫使用的技术框架，就开始着手准备环境的搭建，总的来说环境搭建比较简单。</p><p>1.seleium安装</p><blockquote><p>pip install seleium</p></blockquote><p>2.phantomjs下载</p><p>可以从<a href="http://phantomjs.org/download.html">phantonjs官网</a>选择适合的操作系统下载最新版的程序，同时官网也提供源码下载。</p><p>完成了基础环境的准备，接下来就可以开始进行数据爬取了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.PhantomJS(<span class="string">&#x27;/Users/tian/Downloads/phantomjs-2.1.1-macosx/bin/phantomjs&#x27;</span>)</span><br><span class="line">driver.set_window_size(<span class="string">&quot;800&quot;</span>,<span class="string">&quot;600&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://renren.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------***************---------------------&quot;</span>)</span><br><span class="line">input1 = driver.find_element(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;email&quot;</span>)</span><br><span class="line">input1.send_keys(<span class="string">&quot;****&quot;</span>)</span><br><span class="line">input2 = driver.find_element(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">input2.send_keys(<span class="string">&quot;*****&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;login&quot;</span>).click()</span><br></pre></td></tr></table></figure><p>使用seleium+phantomjs进行人人网的模拟登陆的代码如上，通过seleium的webdriver.PhantomJS拉起phantomJS无界面浏览器，之后的操作类似于JQuery的选择器，找到需要使用的元素，然后设置相关的参数。</p><p>虽然很容易就可以绕过人人网的登录操作，但是并不是没有问题，phantomjs在并发情况下，表现不是很令人满意。最后还是放弃了使用seleium+phantomjs的方式进行数据的爬去。</p><h2 id="分析和设计"><a href="#分析和设计" class="headerlink" title="分析和设计"></a>分析和设计</h2><p>由于seleium+phantomjs表现不能满足需求，不能使用偷懒的方式进行数据获取，只能按部就班的对登陆页面进行分析。最后在github上找到了前人的经验(<a href="https://github.com/XueSeason/renren-album">github链接</a>),作者使用js实现了人人网登陆的密码加密方法。于是发挥python“胶水语言”的特性以及强大的类库支持，也本着不重复造轮子的原则就厚颜无耻的拿过来使用了。</p><p>既然已经解决了登陆密码加密的问题，就可以进行下一步关系网的爬取了。在社交网络中有个六度理论，所以一开始想要从自己的人人账号出发，爬取六度好友，就可以获取所有人人网用户的关系网络。但是这个过程应该是一个先发散后收敛的过程.人人网有上亿用户，所以单任务爬取不是一个可行的方案。需要进行分布式爬取，而采用现有的分布式爬取框架，又觉得有点重，于是设计了如下架构进行这次爬取。</p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-0b3669cd964af72f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬虫架构设计"></p><p>这里redis有两个作用，一个是经常我们使用的共享缓存的作用，还有一个是借用redis中队列数据结构，将任务解耦供多个worker进行分布式爬取好友关系数据。同时为了避难重复爬去而导致的任务无法结束问题，借助redis的bitmap进行过滤已经获取过用户信息，从而避免无限爬取的情况。</p><p>login&#x2F;worker是一个特殊的worker,该worker负责登录并将session信息缓存到redis中，供其他worker使用，然后获取数据源的好友信息，并将其放入redis队列中，之后和其他worker一样消费redis队列中的任务信息，进行分布式爬取。</p><p>worker的设计，为了进一步提升效率，使用线程池+线程的方式进行数据的爬取。由于树莓派的内存限制，导致最后只爬取了自己账号的三度好友的数据。</p><blockquote><p>p.s.爬虫代码上传到了github中（<a href="https://github.com/skystmm/some-spider">传送门</a>）</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次爬虫的编写，一开始走了很多弯路，也有了一些思维定式的原因。一开始主观臆断的选择了seleium+phantomjs方式进行，并没有考虑导数据量的问题和爬取效率的问题。同时也反映出初期准备的时候没有对目标网站连接仔细分析，导致选型上的偏差。从而做了大量的无用功，之后是需要注意的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一开始准备爬取人人网的数据，是因为想把自己的人人数据做一个备份，结果后来就跑偏了，成了爬取好友关系网。（p.s.再一次成功跑偏）。作为拖延症重度患者，本来这个爬虫是在人人网被转卖的时候写好的，但是仅仅是把数据爬了回来，让数据安静的躺在家里的树莓派里。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://stxl117.top/categories/python/"/>
    
    
    <category term="python" scheme="https://stxl117.top/tags/python/"/>
    
    <category term="爬虫" scheme="https://stxl117.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>18年摄影记录</title>
    <link href="https://stxl117.top/2019/01/12/summary2018/"/>
    <id>https://stxl117.top/2019/01/12/summary2018/</id>
    <published>2019-01-12T15:23:17.000Z</published>
    <updated>2024-06-30T09:09:16.873Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7504708-a63a8e9d66c5b756.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/7504708-48b4cf2180f8cdc4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初雪聚贤亭.jpg"></p><p>聚贤亭——西湖十八景之一。刚来杭州那会，经常会在面试完之后的时间来到西湖边坐坐，作为一个刚来杭州的人来说，一切都是新鲜的。虽然当时经常在这里小憩，但是并不知道这个被西湖水环绕的的亭子的名字。第一张照片是17年夏天和朋友路过这里的时候拍摄的，也是那时候才知道了这个亭子叫做聚贤亭。当时就有了一个想法想要记录这里的四季变化和昼夜的不同。<br>聚贤亭—初雪是今年年初正巧赶上了杭州大雪，本来想去看断桥残雪，结果出发途中看到有人发“断桥残（人）雪（满）”的朋友圈后，就直接到了这里，拍下了雪中的聚贤亭。19年争取把当初的想法补齐。</p><span id="more"></span><hr><p><img src="https://upload-images.jianshu.io/upload_images/7504708-f19fd359b2e3053b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西湖长廊"></p><p>姑且叫他西湖长廊吧，不知道这里具体叫什么，拍摄于18年的三月底，那会刚好换工作就给自己放了几天假。三月底四月初的杭州是一年中杭州最美的时间之一。没记错的话中午从医院出来（那段时间在做腰颈的调理）。一路散步到了太子湾公园，还碰到了一些小学的春游活动。漫无目的的绕着西湖边散步，拍下了这张照片。</p><hr><p>还是在换工作的间隙，和罗同学一次去了厦门，然后就有了下面四张照片。不过这里还是要小小的吐槽下自己，整个18年也只和罗同学一起出去过这一次。宅的属性在今年愈发地增长了。<br>直到罗同学说今年的最后一篇公众号文章，要留给我对今年的照片进行一个总结的时候，还是Top10的那种的时候。我才意识到今年基本没怎么拍过照片，同时硬盘了还有海量的拍完就拍完了的照片安静的躺在那里。这张就是众多躺尸的照片中的一张，知道最近周末和朋友去浙大紫金港校区的时候，发现紫金港校区的湖中竟然还有天鹅，当时就感慨浙大的环境和生态真的是好。结果今天整理照片的时候，发现素有中国最美大学的厦大中也有天鹅的存在，不愧是最美的大学（作为一个在武汉读过书的糙汉子，还是觉得厦大比武大要漂亮一些的）。在处理这张照片的时候，本来想文艺一下配首诗什么的，结果检索了半天，只能从匮乏的知识中，想到鹅鹅鹅，曲项向天歌，白（黑）毛浮绿水这句诗，遂作罢了。<br><img src="https://upload-images.jianshu.io/upload_images/7504708-cb2138b5266099b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/7504708-3fc8eccbfc248369.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>还是在厦大，无意间抓拍到的小朋友在吹泡泡。对于常年被吐槽直男人像的我来说，这个应该是人像的巅峰了吧。<br><img src="https://upload-images.jianshu.io/upload_images/7504708-b730b95e66a7367b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="海边晚霞.jpg"><br>来到沿海城市，看海是必不可少的。不同于西湖的有限，海给人一种辽阔，可以抒发一切的感觉。这个角度是看到照片中的小哥哥和他的小姐姐在这里拍摄发现的。然后正巧小哥哥去下面拍大海和鼓浪屿。就有了上面这张照片。感谢小哥哥提供的机位和小哥哥的友情入镜。</p><p>来到厦门，海肯定是必不可少的主题，上一张夕阳中我们在厦门远眺鼓浪屿，那么这下我们就要在鼓浪屿上看一看厦门了。<br><img src="https://upload-images.jianshu.io/upload_images/7504708-ff4920c737800448.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><img src="https://upload-images.jianshu.io/upload_images/7504708-a662ffdcba0abb1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>再不见俯仰的少年格子衬衫一角扬起<br>从此寂寞了的白塔后山今夜悄悄落雨<br>未东去的黄河水打上了刹那的涟漪<br>千里之外的高楼上的你彻夜未眠</p></blockquote><p>这里借用低苦艾的《兰州兰州》中的几句歌词，兰州这座生我养我的城市，对于他的感情是复杂的。从暖和的杭州，和罗同学一起到了秋意浓浓的家乡，牛肉面是必不可少的。当然黄河也是这座城市的主旋律。</p><hr><p><img src="https://upload-images.jianshu.io/upload_images/7504708-a638b9508685e1b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>关于墨宝，没有想到还挺喜欢拉着我陪他玩。在来杭州的日子里，经常帮助我逃避家务。。哈哈哈。。。</p><hr><p><img src="https://upload-images.jianshu.io/upload_images/7504708-97674658ef1c967a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/7504708-64b123c0f1f18cfc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/7504708-0e1b347a97cfbac4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>生活就是点点滴滴，两个人过日子不光是柴米油盐酱醋茶，还可以有花鸟鱼虫来作为调剂。这里不得不得要吐槽下罗同学养花的爱好，今年家里添置了很多花，但是不知道什么时候开始，也许是过了开花的季节后，这些花儿的死活就掌握到了我的手里。。。</p><hr><p>18年就这样过去了，总的来说走出去的时间有点少。希望新的一年可以多带着相机出去走走。再就是要增加运动量，身体才是革命的本钱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7504708-a63a8e9d66c5b756.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7504708-48b4cf2180f8cdc4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;初雪聚贤亭.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;聚贤亭——西湖十八景之一。刚来杭州那会，经常会在面试完之后的时间来到西湖边坐坐，作为一个刚来杭州的人来说，一切都是新鲜的。虽然当时经常在这里小憩，但是并不知道这个被西湖水环绕的的亭子的名字。第一张照片是17年夏天和朋友路过这里的时候拍摄的，也是那时候才知道了这个亭子叫做聚贤亭。当时就有了一个想法想要记录这里的四季变化和昼夜的不同。&lt;br&gt;聚贤亭—初雪是今年年初正巧赶上了杭州大雪，本来想去看断桥残雪，结果出发途中看到有人发“断桥残（人）雪（满）”的朋友圈后，就直接到了这里，拍下了雪中的聚贤亭。19年争取把当初的想法补齐。&lt;/p&gt;</summary>
    
    
    
    <category term="年度总结" scheme="https://stxl117.top/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://stxl117.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年度总结" scheme="https://stxl117.top/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>左耳朵耗子程序员练级攻略(2018)资料整理</title>
    <link href="https://stxl117.top/2018/11/18/study-info/"/>
    <id>https://stxl117.top/2018/11/18/study-info/</id>
    <published>2018-11-18T07:19:46.000Z</published>
    <updated>2024-06-30T09:09:16.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前整理到软件设计文章，高手篇暂未整理</p></blockquote><span id="more"></span><p>获取详细内容，可扫码购买专栏<br><img src="http://image.stxl117.top/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190630182533.jpg" alt="左耳听风专栏"></p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>1.<a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a> (<a href="https://liuyandong.com/2017/10/25/122/">中英对照版</a>)<br>2.<a href="https://coolshell.cn/articles/4235.html">程序员的谎谬之言还是至理名言?</a><br>3.<a href="http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/">The Key To Accelerating Your Coding Skills</a><br>4.<a href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a>（<a href="http://doc.zengrong.net/smart-questions/cn.html">中文版</a>）<br>5.<a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/index.html">97 Things Every Programmer Should Know</a></p><p>6.<a href="https://www.quora.com/What-are-some-of-the-most-basic-things-every-programmer-should-know">What are some of the most basic things every programmer should know</a>（梯子？）<br>7.<a href="http://xyproblem.info/">The XY Problem</a>(<a href="https://coolshell.cn/articles/10804.html">作者中文</a>)</p><p>8.<a href="https://medium.com/@palantir/code-review-best-practices-19e02780015f">Code Review Best Practices</a>（梯子？）<br>9.<a href="https://dzone.com/articles/how-google-does-code-review">How Google Does Code Review</a><br>10.<a href="https://thenewstack.io/linkedin-code-review/">LinkedIn’s Tips for Highly Effective Code Review</a></p><p>11.<a href="https://junit.org/junit5/docs/current/user-guide/">JUnit 5 User Guide</a>(<a href="https://sjyuan.cc/junit5/user-guide-cn/">中文版</a>)<br>12.<a href="https://stackify.com/unit-testing-basics-best-practices/">You Still Don’t Know How to Do Unit Testing</a><br>13.<a href="https://dzone.com/articles/unit-testing-best-practices">Unit Testing Best Practices: JUnit Reference Guide</a><br>14.<a href="https://time.geekbang.org/column/article/8700">JUnit Best Practices</a></p><p>15.<a href="https://security.berkeley.edu/secure-coding-practice-guidelines">伯克立大学的 Secure Coding Practice Guidelines</a><br>16.<a href="https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards">卡内基梅隆大学的 SEI CERT Coding Standards</a></p><p>17.<a href="https://www.oracle.com/technetwork/java/codeconvtoc-136057.html">Java 官方的编程规范</a><br>18.<a href="https://google.github.io/styleguide/javaguide.html">Google 的 Java 编码规范</a></p><p>19.<a href="http://www.kohala.com/start/">W. Richard Stevens’ Home Page</a>(大神博客)</p><p>20.<a href="http://www.kegel.com/c10k.html">C10K 问题</a>(<a href="https://www.oschina.net/translate/c10k">中文版</a>)<br>21.<a href="http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html">C10M 问题</a></p><p>22.<a href="https://en.wikipedia.org/wiki/Programming_paradigm">Programming paradigm</a><br>23.<a href="https://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/">Six programming paradigms that will change how you think about coding</a>(<a href="https://my.oschina.net/editorial-story/blog/890965">中文版</a>)</p><p>24.<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Code Blog</a><br>25.<a href="https://12factor.net/">The Twelve-Factor App</a>(<a href="https://12factor.net/zh_cn/">中文版</a>)<br>26.<a href="https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8">Avoid Over Engineering</a>(梯子？)<br>27.<a href="https://medium.com/@DataStax/instagram-engineerings-3-rules-to-a-scalable-cloud-application-architecture-c44afed31406">Instagram 工程的三个黄金法则</a><br>28.<a href="https://www.infoq.com/presentations/effective-api-design">How to Design a Good API &amp; Why it Matters</a><br>29.<a href="https://blog.codinghorror.com/the-problem-with-logging/">The Problem With Logging</a><br>30.<a href="http://berb.github.io/diploma-thesis/community/index.html">Concurrent Programming for Scalable Web Architectures</a>(一本在线书籍)</p><blockquote><p>6,7为提问能力的方法论<br>8,9,10 code review相关文章<br>11,12,13,14 易测性问题(万恶的法西斯)<br>15,16代码安全guide line<br>17,18 java编程规范（<a href="https://time.geekbang.org/column/article/8700">其他编程规范参见文章</a>）<br>22,23编程范式相关</p></blockquote><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>好的书和不好的书最大的不一样的是，好的书在你不同的阶段来读，你会有不同的收获，而且还会产生更多的深层次的思考！</li></ul><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>1.《代码大全》 pdf<br>2.《Java核心技术·卷 I（原书第10版）》pdf<br>3.《重构：改善既有代码的设计》pdf<br>4.《修改代码的艺术》pdf<br>5.《代码整洁之道》pdf<br>6.《程序员的职业素养》 pdf<br>7.《Spring实战》<br>8.《Spring Boot 实战》pdf<br>9.《Effective Java》<br>10.《java 并发编程实战》<br>11.《java性能权威指南》pdf<br>12.《深入理解java虚拟机》<br>13.《java编程思想》pdf<br>14.《精通 Spring 4.X》pdf<br>15.《设计模式 可复用面向对象软件的基础》pdf<br>16.《<a href="https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf">VanRoyChapter.pdf</a>》</p><ul><li>3-6为程序样的修养相关书籍</li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><p>1.《算法》作者: <a href="https://book.douban.com/search/Robert%20Sedgewick">Robert Sedgewick</a> &#x2F; <a href="https://book.douban.com/search/Kevin%20Wayne">Kevin Wayne</a><br>2.《算法图解》pdf 作者: <a href="https://book.douban.com/search/Aditya%20Bhargava">[美] Aditya Bhargava</a><br>3.《算法导论（原书第3版）》pdf<br>4.《编程珠玑》<br>5.《数据结构与算法分析》pdf</p><blockquote><p>练习网站<a href="https://leetcode.com/">leetcode</a><br>字典网站<a href="https://www.wikiwand.com/en/List_of_algorithms">List of Algorithms</a>和<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></p></blockquote><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>《鸟哥的Linux私房菜》<br>《现代操作系统（第3版）》pdf<br>《计算机程序的构造和解释》pdf<br>《编译原理》pdf<br>《深入理解计算机系统（原书第2版）》 pdf</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">Http官方文档</a><br>《计算机网络》pdf<br>《TCP&#x2F;IP详解（卷一）》</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>《MySql必知必会》<br>《数据库系统概念》pdf</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>《<a href="https://www.owasp.org/images/d/dc/OWASP_Top_10_2017_%E4%B8%AD%E6%96%87%E7%89%88v1.3.pdf">OWASP_Top_10_2017_中文版v1.3.pdf</a>》<br>《Google 软件测试之道》<br>《领域驱动设计》pdf<br>《UNIX编程艺术》pdf<br>《Clean Architecture》</p><blockquote><p> <a href="https://pan.baidu.com/s/1FxB3QkbnAVVOxKWzoJdSVw">资料整理</a> 提取码：ag7u</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目前整理到软件设计文章，高手篇暂未整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计基础" scheme="https://stxl117.top/categories/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="学习路径" scheme="https://stxl117.top/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    
    <category term="资料" scheme="https://stxl117.top/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云搭建hexo博客采坑记录</title>
    <link href="https://stxl117.top/2018/11/11/git-server/"/>
    <id>https://stxl117.top/2018/11/11/git-server/</id>
    <published>2018-11-11T09:48:09.000Z</published>
    <updated>2024-06-30T09:09:16.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git环境搭建"><a href="#git环境搭建" class="headerlink" title="git环境搭建"></a>git环境搭建</h2><p>linux下的git环境搭建可以参考：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">传送门</a></p><span id="more"></span><h2 id="ssh免密登录注意事项"><a href="#ssh免密登录注意事项" class="headerlink" title="ssh免密登录注意事项"></a>ssh免密登录注意事项</h2><h3 id="1-修改sshd读取免密公钥路径"><a href="#1-修改sshd读取免密公钥路径" class="headerlink" title="1.修改sshd读取免密公钥路径"></a>1.修改sshd读取免密公钥路径</h3><p>如果使用git在的.ssh目录，需要在root用户下<br>对shhd_config进行修改，</p><blockquote><p>vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p></blockquote><p>在文件内找到AuthorizedKeysFile配置，配置为自己配置的authorized_keys文件路径</p><h3 id="2-ssh路径的权限问题"><a href="#2-ssh路径的权限问题" class="headerlink" title="2. .ssh路径的权限问题"></a>2. .ssh路径的权限问题</h3><p>需要对.ssh路径权限设置为700，authorized_keys设置为600</p><blockquote><p>chmod 700 .ssh<br>chmod 600 authorized_keys</p></blockquote><h2 id="git初始化以及提交部署问题"><a href="#git初始化以及提交部署问题" class="headerlink" title="git初始化以及提交部署问题"></a>git初始化以及提交部署问题</h2><h3 id="1-初始化空仓库远程提交失败问题"><a href="#1-初始化空仓库远程提交失败问题" class="headerlink" title="1. 初始化空仓库远程提交失败问题"></a>1. 初始化空仓库远程提交失败问题</h3><p>在仓库路径下使用命令，命令行执行</p><blockquote><p>git config receive.denyCurrentBranch ignore</p></blockquote><h3 id="2-提交到仓库后自动部署"><a href="#2-提交到仓库后自动部署" class="headerlink" title="2.提交到仓库后自动部署"></a>2.提交到仓库后自动部署</h3><p>在仓库.git目录下的hooks目录下创建post-recieve文件，来设定提交后部署操作，脚本可参考下面的脚本内容’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">BASE_HOME=&lt;发布路径&gt;</span><br><span class="line">git --work-tree=$&#123;BASE_HOME&#125; --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>最后在hexo的根目录下的_config.yml中添加新建仓库即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;git环境搭建&quot;&gt;&lt;a href=&quot;#git环境搭建&quot; class=&quot;headerlink&quot; title=&quot;git环境搭建&quot;&gt;&lt;/a&gt;git环境搭建&lt;/h2&gt;&lt;p&gt;linux下的git环境搭建可以参考：&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://stxl117.top/categories/hexo/"/>
    
    
    <category term="git" scheme="https://stxl117.top/tags/git/"/>
    
    <category term="hexo" scheme="https://stxl117.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码学习(三)——启动流程之start</title>
    <link href="https://stxl117.top/2018/11/11/tomcat3/"/>
    <id>https://stxl117.top/2018/11/11/tomcat3/</id>
    <published>2018-11-11T06:51:03.000Z</published>
    <updated>2024-06-30T09:09:16.877Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇对于load过程进行学习，从Bootstrap的入口类可以看到启动过程主要分为三个流程——init,load和start。之前已经学习了init和load的源码，今天就来一探tomcat启动中最后一个流程start</p></blockquote><span id="more"></span><p><img src="https://upload-images.jianshu.io/upload_images/136194-3d870c4093e696d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tomcat启动Bootstrap调用顺序"></p><p>之前我们看到bootstarp的start方法实际是通过反射调用了Catalina的start方法，接下来就看一下start方法的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start a new server instance.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">           load();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">           log.fatal(<span class="string">&quot;Cannot start server. Server instance is not configured.&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">       <span class="comment">// Start the new server</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           getServer().start();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">           log.fatal(sm.getString(<span class="string">&quot;catalina.serverStartFail&quot;</span>), e);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               getServer().destroy();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;destroy() failed for failed Server &quot;</span>, e1);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">       <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">           log.info(<span class="string">&quot;Server startup in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Register shutdown hook</span></span><br><span class="line">       <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">           <span class="keyword">if</span> (shutdownHook == <span class="literal">null</span>) &#123;</span><br><span class="line">               shutdownHook = <span class="keyword">new</span> <span class="title class_">CatalinaShutdownHook</span>();</span><br><span class="line">           &#125;</span><br><span class="line">           Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If JULI is being used, disable JULI&#x27;s shutdown hook since</span></span><br><span class="line">           <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">           <span class="comment">// if JULI&#x27;s hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">           <span class="type">LogManager</span> <span class="variable">logManager</span> <span class="operator">=</span> LogManager.getLogManager();</span><br><span class="line">           <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">               ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                       <span class="literal">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (await) &#123;</span><br><span class="line">           await(); <span class="comment">//监听关闭服务连接信息端口并阻塞，默认8005</span></span><br><span class="line">           stop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先可以看到，会对server进行npl检测，如果server没有初始化就会调用load方法来进行初始化工作，然后映入眼帘的就是Start方法——今天的正主了；完成start后，会向JVM中添加钩子方法，这里的钩子方法时为了优雅的关闭tomcat。</p><p>点到getServer().start()方法，会发现有一次来到了LifecycleBase类，这会不一样的是我们看到的是一个新的模板方法start。让我们来先看看start方法都做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">                LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>();</span><br><span class="line">                log.debug(sm.getString(<span class="string">&quot;lifecycleBase.alreadyStarted&quot;</span>, toString()), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(sm.getString(<span class="string">&quot;lifecycleBase.alreadyStarted&quot;</span>, toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">                !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTING_PREP, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            startInternal();</span><br><span class="line">            <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">                <span class="comment">// This is a &#x27;controlled&#x27; failure. The component put itself into the</span></span><br><span class="line">                <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">                stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">                <span class="comment">// Shouldn&#x27;t be necessary but acts as a check that sub-classes are</span></span><br><span class="line">                <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">                invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setStateInternal(LifecycleState.STARTED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// This is an &#x27;uncontrolled&#x27; failure so put the component into the</span></span><br><span class="line">            <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">            handleSubClassException(t, <span class="string">&quot;lifecycleBase.startFail&quot;</span>, toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到start的实现，会发现比init方法处理复杂了很多，细看会发现start方法会对当前的LifecycleBase实例的状态进行判断，然后调用startInternal方法，然后根据startInternal的结果，再次更新该实例的状态。相当于一个流程控制。这里又引出了startInternal方法，这个就会在继承了LifecycleBase的实现类中实现了，上文中提到过tomcat默认的server是StandardServer，那么就来看看server的Start到底做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="literal">null</span>);</span><br><span class="line">       setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">       globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Start our defined Services</span></span><br><span class="line">       <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">               services[i].start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从代码汇总可以看到，StandardServr的start过程是先根据Server实例创建生命周期事件实例，再将该事件实例依次注册到配置的listener上。最后一次执行Service的start方法来启动配置的ServerService。在对load过程学习的时候，我们知道默认情况下ServerServIce只有一个——StandardService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">           log.info(sm.getString(<span class="string">&quot;standardService.start.name&quot;</span>, <span class="built_in">this</span>.name));</span><br><span class="line">       setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Start our defined Container first</span></span><br><span class="line">       <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">               engine.start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (executors) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Executor executor: executors) &#123;</span><br><span class="line">               executor.start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mapperListener.start();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Start our defined Connectors second</span></span><br><span class="line">       <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">               <span class="comment">// If it has already failed, don&#x27;t try and start it</span></span><br><span class="line">               <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                   connector.start();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到start过程和load过程是对应的，不过相对于load过程，对于container，executor和connector的start都使用了同步操作。</p><p>那么就先来看看Container的启动过程，根据load学习，得知了默认的container是StandardEngine，它的UML关系如下<br><img src="https://upload-images.jianshu.io/upload_images/7504708-cd41e2e41f6b61bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="StandardEngine 继承关系"></p><p>阅读源码会发现StandardEngine的启动过程，是在其父类ContainerBase中实现的，话不多说先来一波源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">       <span class="comment">// Start our subordinate components, if any</span></span><br><span class="line">       logger = <span class="literal">null</span>;</span><br><span class="line">       getLogger();</span><br><span class="line">       <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> getClusterInternal();</span><br><span class="line">       <span class="keyword">if</span> (cluster <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">           ((Lifecycle) cluster).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Realm</span> <span class="variable">realm</span> <span class="operator">=</span> getRealmInternal();</span><br><span class="line">       <span class="keyword">if</span> (realm <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">           ((Lifecycle) realm).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Start our child containers, if any</span></span><br><span class="line">       Container children[] = findChildren();</span><br><span class="line">       List&lt;Future&lt;Void&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">           results.add(startStopExecutor.submit(<span class="keyword">new</span> <span class="title class_">StartChild</span>(children[i])));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">MultiThrowable</span> <span class="variable">multiThrowable</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               result.get();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               log.error(sm.getString(<span class="string">&quot;containerBase.threadedStartFailed&quot;</span>), e);</span><br><span class="line">               <span class="keyword">if</span> (multiThrowable == <span class="literal">null</span>) &#123;</span><br><span class="line">                   multiThrowable = <span class="keyword">new</span> <span class="title class_">MultiThrowable</span>();</span><br><span class="line">               &#125;</span><br><span class="line">               multiThrowable.add(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (multiThrowable != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(sm.getString(<span class="string">&quot;containerBase.threadedStartFailed&quot;</span>),</span><br><span class="line">                   multiThrowable.getThrowable());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Start the Valves in our pipeline (including the basic), if any</span></span><br><span class="line">       <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">           ((Lifecycle) pipeline).start();</span><br><span class="line">       &#125;</span><br><span class="line">       setState(LifecycleState.STARTING);</span><br><span class="line">       <span class="comment">// Start our thread</span></span><br><span class="line">       threadStart();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在container的启动过程中，会异步的对container的子container进行Start的操作。并通过Future来获取其子container的Start结果，如果其中任何一个子container启动异常，都会添加到multiThrowable实例中，然后抛出异常。最后拉起Container的校验session有效期的线程,同时该线程也是一个守护线程。同时在启动Container的时，会对webapp(在server.xml中可进行配置)目录下，自己发布的应用程序进行加载和初始化。</p><p>接下来对配置的工作线程池进行启动操作，源码中提供的默认server.xml中并没有配置工作线程池，不配置时所有的connector共享一个默认线程池，配置后connector可以使用专属的线程池,给8080端口配置使用名称为tomcatThreadPool的线程池，方法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">namePrefix</span>=<span class="string">&quot;catalina-exec-&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>访问8080端口时，将会使用tomcatThraeadPool这个线程池中的线程进行处理，而不是默认线程池。最后进行connector的启动。到这里tomcat完成了整个启动过程，可以对外提供服务了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上一篇对于load过程进行学习，从Bootstrap的入口类可以看到启动过程主要分为三个流程——init,load和start。之前已经学习了init和load的源码，今天就来一探tomcat启动中最后一个流程start&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="tomcat" scheme="https://stxl117.top/tags/tomcat/"/>
    
    <category term="源码" scheme="https://stxl117.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码学习（二）——启动流程之load初探</title>
    <link href="https://stxl117.top/2018/11/05/Tomcat%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Bload%E5%88%9D%E6%8E%A2/"/>
    <id>https://stxl117.top/2018/11/05/Tomcat%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Bload%E5%88%9D%E6%8E%A2/</id>
    <published>2018-11-05T12:50:02.000Z</published>
    <updated>2024-06-30T09:09:16.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上次对于Bootstrap类进行了学习，并且引出了Tomcat启动过程中一直有调用的Catalina类，今天就对Catalina类进行学习和分析。</p></blockquote><span id="more"></span><p>根据Bootstrap类的main方法的调用顺序如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/136194-3d870c4093e696d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tomcat启动Bootstrap调用顺序"></p><p>Bootstrap的实例在执行load方法实际调用的是Catalina的load方法。查看Catalina的源码可以发现有两个load方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(String args[])</span>; <span class="comment">//对参数进行解析后在调用load()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>load的具体实现是在无参的load方法中，下面来看一下load方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loaded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        initDirs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">        initNaming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and execute our Digester</span></span><br><span class="line">        <span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> createStartDigester();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file = configFile();</span><br><span class="line">                inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span>(file.toURI().toURL().toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream = getClass().getClassLoader()</span><br><span class="line">                        .getResourceAsStream(getConfigFile());</span><br><span class="line">                    inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span></span><br><span class="line">                        (getClass().getClassLoader()</span><br><span class="line">                         .getResource(getConfigFile()).toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile()), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">            <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">            <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream = getClass().getClassLoader()</span><br><span class="line">                            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">                    inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span></span><br><span class="line">                    (getClass().getClassLoader()</span><br><span class="line">                            .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputStream == <span class="literal">null</span> || inputSource == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>  (file == <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                            getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                            file.getAbsolutePath()));</span><br><span class="line">                    <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputSource.setByteStream(inputStream);</span><br><span class="line">                digester.push(<span class="built_in">this</span>);</span><br><span class="line">                digester.parse(inputSource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                        spe.getMessage());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServer().setCatalina(<span class="built_in">this</span>);</span><br><span class="line">        getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">        getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stream redirection</span></span><br><span class="line">        initStreams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the new server</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.Error(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一眼看到load方法的代码，会觉得这个方法的代码很冗长，详细看一下代码会发现，load方法的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> createStartDigester(); <span class="comment">//创建xml的解析规则</span></span><br><span class="line">file = configFile();<span class="comment">//获取配置文件的信息</span></span><br><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span>(file.toURI().toURL().toString());</span><br><span class="line">inputSource.setByteStream(inputStream);</span><br><span class="line">digester.push(<span class="built_in">this</span>);</span><br><span class="line">digester.parse(inputSource);<span class="comment">//进行xml的解析</span></span><br><span class="line">getServer().setCatalina(<span class="built_in">this</span>);<span class="comment">//设置Server的catalina</span></span><br><span class="line">getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());        getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line">initStreams();</span><br><span class="line">getServer().init();</span><br></pre></td></tr></table></figure><p>这么看下来，load方法其实做了三件事，一件是通过createStartDigester方法创建默认的Tomcat服务配置信息；第二件事是去读取conf&#x2F;server.xml信息并解析和更新默认的配置信息；最后一件事就是根据合并后的配置信息来对tomcat server进行初始化。上面的load核心代码中，大部分都是在做server.xml的解析准备和解析工作，而真正的Server初始化则是在<code>getServer().init()</code>进行的。<br>在digerster中可以看到，默认使用的server是org.apache.catalina.core.StandardServer，首先我们来看看StandardServer的UML图<br><img src="https://upload-images.jianshu.io/upload_images/7504708-2eb08e702eabeb3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="StandardServerUML图"></p><p>从上图中StandardServer继承了LifecycleMBeanBase抽献类，并且实现了Server接口。点进去getServer().init()的方法，会发现init方法是LifecycleBase抽象类中的一个模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">       <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">           invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           setStateInternal(LifecycleState.INITIALIZING, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">           initInternal();</span><br><span class="line">           setStateInternal(LifecycleState.INITIALIZED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到具体的实现在对应实现类的initInternal方法中，下面来一起看看StandardServer中server的init过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register global String cache</span></span><br><span class="line">        <span class="comment">// Note although the cache is global, if there are multiple Servers</span></span><br><span class="line">        <span class="comment">// present in the JVM (may happen when embedding) then the same cache</span></span><br><span class="line">        <span class="comment">// will be registered under multiple names</span></span><br><span class="line">        onameStringCache = register(<span class="keyword">new</span> <span class="title class_">StringCache</span>(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the MBeanFactory</span></span><br><span class="line">        <span class="type">MBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBeanFactory</span>();</span><br><span class="line">        factory.setContainer(<span class="built_in">this</span>);</span><br><span class="line">        onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the naming resources</span></span><br><span class="line">        globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Populate the extension validator with JARs from common and shared</span></span><br><span class="line">        <span class="comment">// class loaders</span></span><br><span class="line">        <span class="keyword">if</span> (getCatalina() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> getCatalina().getParentClassLoader();</span><br><span class="line">            <span class="comment">// Walk the class loader hierarchy. Stop at the system class loader.</span></span><br><span class="line">            <span class="comment">// This will add the shared (if present) and common class loaders</span></span><br><span class="line">            <span class="keyword">while</span> (cl != <span class="literal">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                    URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">                    <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span> (url.toURI());</span><br><span class="line">                                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                                        f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                                    ExtensionValidator.addSystemResource(f);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                                <span class="comment">// Ignore</span></span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="comment">// Ignore</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = cl.getParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Initialize our defined Services</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">            services[i].init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>StanderServer的initInternal方法，主要是进行了自己serverice的初始化工作，依次执行每个service的init方法。完成了Server&#x2F;Service的初始化，这里Catalina的load方法就结束了。通过查看Digster实例的创建代码的和server.xml，可以了解到tomcat默认的server&#x2F;service为org.apache.catalina.core.StandardService。接下来我们就来看看StandardService的init都做了些什么。</p><p>看源码之前，先来看一下StandardService的UML类图<br><img src="https://upload-images.jianshu.io/upload_images/7504708-967d0930242f2402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="StandardService类图"></p><p>可以看到StandardService继承了LifecycleMBeanBase抽象类，实现了Service接口。其中LifecycleMBeanBase抽象类是老朋友了，之前的StandardServer也是继承了这个抽象类，既然StandardService也继承了它，那我们就跳过init这个使用模板设计模式的方法，直接来看看StandardService的初始化都做了些什么。废话不多直接上源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any Executors</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">            ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize mapper listener</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">            connector.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这段代码，首先会发现其中有很多init方法，然后会发现这些众多的init方法的实例的实现类都继承了LifecycleMBeanBase抽象类。在service的中初始化了container(这里的engine实例),多个连接器（connector）,多个executor和一个mapperListener。</p><p>使用默认的server.xml时，container使用的是默认的StandardEngine,作为默认的tomcat容器。connector是根据server.xml中的Connector标签中配置的信息，即对外暴露的端口连接器信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>下面来看下一load过程的流程图<br>  <img src="https://upload-images.jianshu.io/upload_images/7504708-27efe74fc8370abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="load流程图"></p><p>至此catalina的load过程就完成了。回顾一下load过程首先是是创建了一个digster对象，这个digster对象可以说是对于我们了解load过程，一个很重要的对象，可以帮我们梳理load过程和加载了那些对象，然后读取了server.xml中的内容，server.xml中的内容是对于digster的一个补充的完善；然后根据配置信息初始化Server容器，以及service相关初始化工作。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上次对于Bootstrap类进行了学习，并且引出了Tomcat启动过程中一直有调用的Catalina类，今天就对Catalina类进行学习和分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="tomcat" scheme="https://stxl117.top/tags/tomcat/"/>
    
    <category term="源码" scheme="https://stxl117.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码学习（一）——Bootstarp入口类</title>
    <link href="https://stxl117.top/2018/11/05/Tomcat%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Bootstarp%E5%85%A5%E5%8F%A3%E7%B1%BB/"/>
    <id>https://stxl117.top/2018/11/05/Tomcat%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Bootstarp%E5%85%A5%E5%8F%A3%E7%B1%BB/</id>
    <published>2018-11-05T12:40:55.000Z</published>
    <updated>2024-06-30T09:09:16.855Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat作为平时工作中出镜率最高的web容器，今天我们就来对其源码一探究竟。通过github获取了tomcat的最新代码，获取地址如下</p><blockquote><p><a href="https://github.com/apache/tomcat">https://github.com/apache/tomcat</a></p></blockquote><p>这里使用idea的git直接从github上拉去了最新源码，同时方便获取最新修改。</p><span id="more"></span><p>获得源码后，首先来探索一下Tomcat的启动过程，那就要来看看他的启动入口类org.apache.catalina.startup.BootStrap。<br>找到了入口类，从main方法开始入手，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">// 同步初始化Bootstrap对象,不太理解这里为什么要加同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">                <span class="comment">// thread so make sure the correct class loader is used to</span></span><br><span class="line">                <span class="comment">// prevent a range of class not found exceptions.</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                daemon.setAwait(<span class="literal">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述是tomcat的main方法，如果我只看tomcat的start过程，代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (daemon == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">  bootstrap.init();</span><br><span class="line">  daemon = bootstrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  daemon.setAwait(<span class="literal">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上面代码就可以清晰的看出来tomcat 启动流程，首先创建bootstrap对象，并执行init方法初始化bootstrap,初始化完成后将新创建的bootstrap实例赋值给daemon对象，在启动时，daemon会先调用Bootstrap的load方法和start方法来完成Tomcat的启动工作。</p><p>从main方法中可以发现启动过程中主要的三个方法init,load和start。依次来看一下这三个方法的实现，来了解一下tomcat启动具体做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        initClassLoaders(); <span class="comment">//类加载器初始化</span></span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">        SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">startupInstance</span> <span class="operator">=</span> startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">        Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">        paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">        Object paramValues[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span></span><br><span class="line">            startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">        method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">        catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到init方法是设置了类加载器，同时通过类加载器，生成了一个Catalina对象实例，同时设置了catalina对象的父类加载器。并将生成的catalina对象赋值给了bootstrap对象的catalinaDaemon属性。上述操作，总的来看init方法做了一件事情，就是给bootstarp的catalinaDanmon属性进行了初始化。<br>再来看看load方法做了什么事情，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span></span><br><span class="line">    catalinaDaemon.getClass().getMethod(methodName, paramTypes);</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Calling startup class &quot;</span> + method);</span><br><span class="line">method.invoke(catalinaDaemon, param);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到load方法其实是通过反射的方法调动了catalina的load方法。进行基础信息的加载。catalina的load将在后续文章中详细介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( catalinaDaemon==<span class="literal">null</span> ) init();</span><br><span class="line"></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> catalinaDaemon.getClass().getMethod(<span class="string">&quot;start&quot;</span>, (Class [] )<span class="literal">null</span>);</span><br><span class="line">      method.invoke(catalinaDaemon, (Object [])<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>start方法也很简单，依然是通过反射的方法调用了catalina的start 方法。</p><p>翻看了其他的Bootstarp类方法，大部分都是通过反射去调用了对应的Catalina类的对应方法来完成对应操作。</p><p>可以看到Bootstrap类如其名，作为tomcat的入口类，同时起到了一个引导的作用，通过阅读和分析，也引出了tomcat启动过程中一个重要的类Catalina。</p><blockquote><p>对于源码中同步疑问，在万能的stackoverflow提问后，理解了为什么要对daemon的初始化过程进行同步操作<br><a href="https://stackoverflow.com/questions/52980662/why-tomcat-lastest-code-use-synchronized-in-main-method">传送门</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tomcat作为平时工作中出镜率最高的web容器，今天我们就来对其源码一探究竟。通过github获取了tomcat的最新代码，获取地址如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apache/tomcat&quot;&gt;https://github.com/apache/tomcat&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里使用idea的git直接从github上拉去了最新源码，同时方便获取最新修改。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="tomcat" scheme="https://stxl117.top/tags/tomcat/"/>
    
    <category term="源码" scheme="https://stxl117.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>大麦网数据分析</title>
    <link href="https://stxl117.top/2018/06/25/%E5%A4%A7%E9%BA%A6%E7%BD%91%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://stxl117.top/2018/06/25/%E5%A4%A7%E9%BA%A6%E7%BD%91%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2018-06-25T12:03:10.000Z</published>
    <updated>2024-06-30T09:09:16.877Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到很多爬虫到各种各样数据进行分析的文章，于是自己也想小试牛刀一下。最后决定尝试爬一下大麦网的数据。</p><span id="more"></span><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>决定了要爬去的目标，就开始对目标数据获取进行分析，通过chrome抓包分析接口，发现可以直接通过接口获取售卖信息的json数据，这样就可以省去对html的解析工作。顺便尝试一下python3的urllib3来获取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">pool = urllib3.PoolManager()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Name&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: base_page&#125;</span><br><span class="line"></span><br><span class="line">response = pool.request(<span class="string">&#x27;POST&#x27;</span>,url,param,headers=headers)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先使用PoolManager来创建连接池，然后使用request方法来模拟数据获取接口请求，一开始没有添加http header伪装，在爬去到第15页左右数据时，开始出现访问被拒绝的情况。添加header以及添加两次请求间的时间价格，就可以完美的避开大麦的反扒机制。</p><p>获取到数据后，会将数据保存到树莓派的mongoDB上（也是将买回来一直吃土的树莓派用起来）。主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line">cf.read(<span class="string">&quot;C:/Users/Administrator/PycharmProjects/spider/spider/config.ini&quot;</span>)</span><br><span class="line">url = cf.get(<span class="string">&#x27;mongo&#x27;</span>, <span class="string">&#x27;mongo.url&#x27;</span>)</span><br><span class="line">conn = MongoClient(cf.get(<span class="string">&#x27;mongo&#x27;</span>, <span class="string">&#x27;mongo.url&#x27;</span>), cf.getint(<span class="string">&#x27;mongo&#x27;</span>, <span class="string">&#x27;mongo.port&#x27;</span>))</span><br><span class="line">db = conn.damai  <span class="comment"># 连接mydb数据库，没有则自动创建</span></span><br><span class="line">data_set = db.damai_set</span><br><span class="line"></span><br><span class="line">ids = data_set.insert(data)</span><br></pre></td></tr></table></figure><p>这样就完成了，大麦网数据的爬去和存盘工作。</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>第一次做数据分析，爬去的数据量也不大，总共爬去了当前有效的售票信息4847条。数据量和看的其他文章完全不在一个量级。首先对爬取数据按照城市进行了分类。</p><p><img src="http://image.stxl117.top/%E5%9F%8E%E5%B8%82%E5%88%86%E5%B8%83.png" alt="大麦数据城市分类"></p><p>可以看到意料之中的北上，排名第一第二，而第三名的武汉则场次数不到上海场次数的一半，这里只展示了排名前十五的城市。比较意外的是南京的场次数，因为以前有朋友说，南京是出了北上广深以外，演出最多的城市。然后再从地图的上直观的看一下演出分布的情况，如下图(<a href="http://image.stxl117.top/%E5%94%AE%E7%A5%A8%E5%9F%8E%E5%B8%82%E5%88%86%E5%B8%83.html">地图动态信息链接</a>)</p><p><img src="http://image.stxl117.top/QQ%E5%9B%BE%E7%89%8720180722224859.png" alt="大麦数据城市分布详情"></p><p><img src="http://image.stxl117.top/%E7%B1%BB%E5%9E%8B%E5%88%86%E5%B8%83.png" alt="演出类型"></p><p>从上图中可以看出，按照大麦大类来进行区分的话，售票信息最多的是话剧歌剧类。</p><p><img src="http://image.stxl117.top/%E6%97%B6%E9%97%B4%E5%88%86%E5%B8%83.png" alt="时间分布"></p><p>从时间分布上来看，暑期档也是演出比较集中的时间。</p><p><img src="http://image.stxl117.top/%E6%BC%94%E5%94%B1%E4%BC%9A%E5%9F%8E%E5%B8%82%E5%88%86%E5%B8%83.png" alt="演唱会城市分布"><br>可以看到上海是演唱会场次数最多的城市，第二名的海外范围比较大。</p><p><img src="http://image.stxl117.top/%E8%AF%9D%E5%89%A7%E6%AD%8C%E5%89%A7%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%88%86%E5%B8%83.png" alt="演唱会城市分布"></p><p>从“话剧歌剧”这个场次数占比最大的分类在进行分析，发现儿童剧是这个大麦中占比最高的子分类项目。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次做大麦网的数据爬取和分析，主要是小试牛刀。其中主要使用了python3中的额urllib3,pymongo,pyecharts,pandas等包，学习了使用urllib3进行爬虫，同时学习使用了pandas这个数据科学高频包的使用，一开始准备使用matplotlib进行数据图的绘制，但是由于汉字的问题，踩了很多坑，最后还是使用了更为熟悉的pyecharts包来进行数据图表的渲染。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看到很多爬虫到各种各样数据进行分析的文章，于是自己也想小试牛刀一下。最后决定尝试爬一下大麦网的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://stxl117.top/categories/python/"/>
    
    
    <category term="python" scheme="https://stxl117.top/tags/python/"/>
    
    <category term="爬虫" scheme="https://stxl117.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析</title>
    <link href="https://stxl117.top/2018/05/15/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-md/"/>
    <id>https://stxl117.top/2018/05/15/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-md/</id>
    <published>2018-05-15T14:45:58.000Z</published>
    <updated>2024-06-30T09:09:16.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><h2 id="AbstractQueuedSynchronizer类结构分析"><a href="#AbstractQueuedSynchronizer类结构分析" class="headerlink" title="AbstractQueuedSynchronizer类结构分析"></a>AbstractQueuedSynchronizer类结构分析</h2><p><img src="http://image.stxl117.top/AQS.png" alt="AbstractQueuedSynchronizer"></p><p>其中AbstractOwnaleSynchronizer提供了当前资源拥有者相关的操作，AbatractQueuedSynchronizer（下文中简称为AQS）这个抽象类中主要提供了对互斥锁和共享锁相关操作提供了基础功能的实现，以及提供了对于不同场景下的加锁和释放锁的方法定义。</p><p>而AQS这个抽象类中主要为我们提供了对于CLH队列的一系列操作，包括无法获得请求资源时的如队列操作和资源释放时怎么通知等待队列中的节点获取资源的操作。这样使得我们在需要自己实现锁功能时，只要需要专注于具体的加锁和释放锁操作。下面来看一下AQS中核心的数据结构CLH队列。</p><span id="more"></span><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>上面基础数据结构为Node，Node为一个双向链表结构。CLH中节点数据结实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出CLH队列是一个双线链表结构，每个节点包含线程信息和状态信息。</p><h2 id="独占模式下的CLH操作"><a href="#独占模式下的CLH操作" class="headerlink" title="独占模式下的CLH操作"></a>独占模式下的CLH操作</h2><h3 id="1-加锁"><a href="#1-加锁" class="headerlink" title="1.加锁"></a>1.加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过AQS的源码可以看到获取独享锁时，首先调用tryAcquire方法进行锁获取，而AQS源码中我们发现tryAcuire方法为一个抽象方法，所以获取锁资源是根据具体的业务要求，有具体类进行实现的。而获取锁失败后，首先执行addWaiter方法，addWaiter方法是将当前请求线程信息构造成CLH队列中的节点，然后再将节点插入到队列的队尾，同时返回创建的这个node节点，然后执行acquireQueued方法，下面看下acquireQueued的实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法中，可以看到如果新加的节点是第一个节点，将再尝试获取获取锁一次，如果获取成功，进行将其从队列中移除，并返回。如果不是第一个节点，则设置节点状态，并挂起该线程。</p><p>大致加锁流程为：</p><h3 id="2-释放锁"><a href="#2-释放锁" class="headerlink" title="2.释放锁"></a>2.释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和获取资源一样，释放资源的时候，还是先调用tryRelease方法进行资源释放，同样的tryRealse方法也是抽象方法，需要在具体实现类中进行具体实现的。当资源释放后，且CLH等待队列不为空时，会进行队列中节点唤醒的操作，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到唤醒时有两种情况，正常情况下是唤醒头结点后的第一个节点，当头结点下一个节点为空时后者该节点状态不为SIGNAL时，将从尾节点开始开始向前遍历找到排在最前面的一个为SIGNAL的节点，唤醒对应的线程进行锁资源的获取。</p><p>大体流程如下图所示：</p><blockquote><p>具体实现tryAcquire和tryRelease可以参考Juc包中的ReentrantLock类</p></blockquote><h2 id="共享模式下的CLH操作"><a href="#共享模式下的CLH操作" class="headerlink" title="共享模式下的CLH操作"></a>共享模式下的CLH操作</h2><h3 id="1-加锁-1"><a href="#1-加锁-1" class="headerlink" title="1.加锁"></a>1.加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireShared(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同样的我们需要在具体的场景下实现tryAcquireShared方法，来实现加锁的过程。而AQS则我们实现了，未获取到所情况时，对于获取锁失败的线程的等待操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到共享锁的未获取到资源情况的操作与独占锁类似，都是将该线程挂起，并创建对应的Node节点插入到CLH等待队列中。</p><h3 id="2-释放锁-1"><a href="#2-释放锁-1" class="headerlink" title="2.释放锁"></a>2.释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到共享锁的未获释放资源情况的操作与独占锁类似。</p><blockquote><p>具体实现tryAcquire和tryRelease可以参考Juc包中的ReentrantReadWriteLock类中读锁的实现</p></blockquote><p>总的来说AQS用模板方法的方式，定义了通过Cas获取和释放锁的流程，以及对于等待节点的操作。而我们在使用已AQS为框架自实现锁时，只需要专注于获取锁和释放锁的具体细节实现，即可完成自定义锁的功能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AQS源码分析&quot;&gt;&lt;a href=&quot;#AQS源码分析&quot; class=&quot;headerlink&quot; title=&quot;AQS源码分析&quot;&gt;&lt;/a&gt;AQS源码分析&lt;/h1&gt;&lt;h2 id=&quot;AbstractQueuedSynchronizer类结构分析&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer类结构分析&quot; class=&quot;headerlink&quot; title=&quot;AbstractQueuedSynchronizer类结构分析&quot;&gt;&lt;/a&gt;AbstractQueuedSynchronizer类结构分析&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://image.stxl117.top/AQS.png&quot; alt=&quot;AbstractQueuedSynchronizer&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中AbstractOwnaleSynchronizer提供了当前资源拥有者相关的操作，AbatractQueuedSynchronizer（下文中简称为AQS）这个抽象类中主要提供了对互斥锁和共享锁相关操作提供了基础功能的实现，以及提供了对于不同场景下的加锁和释放锁的方法定义。&lt;/p&gt;
&lt;p&gt;而AQS这个抽象类中主要为我们提供了对于CLH队列的一系列操作，包括无法获得请求资源时的如队列操作和资源释放时怎么通知等待队列中的节点获取资源的操作。这样使得我们在需要自己实现锁功能时，只要需要专注于具体的加锁和释放锁操作。下面来看一下AQS中核心的数据结构CLH队列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2018读书计划及笔记</title>
    <link href="https://stxl117.top/2018/01/28/2018%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92%E5%8F%8A%E7%AC%94%E8%AE%B0/"/>
    <id>https://stxl117.top/2018/01/28/2018%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92%E5%8F%8A%E7%AC%94%E8%AE%B0/</id>
    <published>2018-01-28T14:00:28.000Z</published>
    <updated>2024-06-30T09:09:16.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018学习读书记录"><a href="#2018学习读书记录" class="headerlink" title="2018学习读书记录"></a>2018学习读书记录</h1><h2 id="读书单"><a href="#读书单" class="headerlink" title="读书单"></a>读书单</h2><h3 id="技术书籍"><a href="#技术书籍" class="headerlink" title="技术书籍"></a>技术书籍</h3><ol><li>Java并发编程实战（计划）</li><li>Java并发编程艺术（正在阅读）</li><li>深入理解java虚拟机（计划）</li><li>hadoop权威指南（计划）</li><li>Python网络数据采集（已读）</li></ol><span id="more"></span><h3 id="其他书籍"><a href="#其他书籍" class="headerlink" title="其他书籍"></a>其他书籍</h3><ol><li>高效能阅读 （finish 2月21）</li><li>如何有效阅读（已读）</li></ol><h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2018学习读书记录&quot;&gt;&lt;a href=&quot;#2018学习读书记录&quot; class=&quot;headerlink&quot; title=&quot;2018学习读书记录&quot;&gt;&lt;/a&gt;2018学习读书记录&lt;/h1&gt;&lt;h2 id=&quot;读书单&quot;&gt;&lt;a href=&quot;#读书单&quot; class=&quot;headerlink&quot; title=&quot;读书单&quot;&gt;&lt;/a&gt;读书单&lt;/h2&gt;&lt;h3 id=&quot;技术书籍&quot;&gt;&lt;a href=&quot;#技术书籍&quot; class=&quot;headerlink&quot; title=&quot;技术书籍&quot;&gt;&lt;/a&gt;技术书籍&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Java并发编程实战（计划）&lt;/li&gt;
&lt;li&gt;Java并发编程艺术（正在阅读）&lt;/li&gt;
&lt;li&gt;深入理解java虚拟机（计划）&lt;/li&gt;
&lt;li&gt;hadoop权威指南（计划）&lt;/li&gt;
&lt;li&gt;Python网络数据采集（已读）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="other" scheme="https://stxl117.top/categories/other/"/>
    
    
    <category term="读书笔记" scheme="https://stxl117.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端获取实时数据探索</title>
    <link href="https://stxl117.top/2018/01/06/%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"/>
    <id>https://stxl117.top/2018/01/06/%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/</id>
    <published>2018-01-06T14:05:33.000Z</published>
    <updated>2024-06-30T09:09:16.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端获取实时数据探索"><a href="#前端获取实时数据探索" class="headerlink" title="前端获取实时数据探索"></a>前端获取实时数据探索</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近在工作中，有个需求是前端需要获取实时展示最新的n条报警数据。使用http的请求响应，一问一答方式获取数据时，就出现可能部分数据获取不到的问题，然后在网上寻找和咨询老同事相关解决方案的时<br>候，发现有使用DWR的方式进行向前端推送的解决方案，</p><span id="more"></span><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-ajax订阅ActiveMQ"><a href="#1-ajax订阅ActiveMQ" class="headerlink" title="1.ajax订阅ActiveMQ"></a>1.ajax订阅ActiveMQ</h3><p>ajax订阅activeMQ获取实时数据的流程如下<br><img src="/../../images/ajax.png" alt="ajax订阅activeMQ数据流程图"></p><p>使用ajax直接获取ActiveMQ topic中的数据，可以在activeMQ 官网中，找到Demo。需要在相应的页面中引入amq.js,amq_jquery_adapter.js以及jquery-1.4.2.min.js三个js文件，并且在后端添加相应的servlet配置。</p><p>demo中给出的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AjaxServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.activemq.web.AjaxServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AjaxServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/amq/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- activeMQ 服务地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>org.apache.activemq.brokerURL<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>tcp://127.0.0.1:61616<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时我们需要在项目中引入对应版本的activeMQ-web.jar。来提供对订阅MQ的支持，这样在相应页面添加对应的Js订阅代码，就可以实现使用ajax订阅activeMQ topic进行消费的目的。</p><p>虽然这样就可以解决问题，但是总觉得将MQ地址直接配置到web.xml中，这种实现方式很不优雅，通过对AjaxServlet以及其父类源码阅读，发现在创建MQ连接的方式有两种，一种是通过获取获取servlet上下文中初始化时添加的全局参数org.apache.activemq.brokerURL，来创建和MQ的连接，就是上面看到的配置文件中的方法，还有一种是从serlvet上下文中获取创建连接的工厂类进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从servlet上下文中获取连接工厂的属性名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONNECTION_FACTORY_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;org.apache.activemq.connectionFactory&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">initConnectionFactory</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//获取servlet上下文中的连接工厂实例</span></span><br><span class="line">            factory = (ActiveMQConnectionFactory)servletContext.getAttribute(CONNECTION_FACTORY_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123; <span class="comment">//连接工厂实例为null时，获取brokeURL等参数信息，并新建连接工厂实例</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">brokerURL</span> <span class="operator">=</span> getInitParameter(servletContext, BROKER_URL_INIT_PARAM);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerURL == <span class="literal">null</span>) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Couldn&#x27;t find &quot;</span> + BROKER_URL_INIT_PARAM + <span class="string">&quot; param, trying to find a broker embedded in a local VM&quot;</span>);</span><br><span class="line">                <span class="type">BrokerService</span> <span class="variable">broker</span> <span class="operator">=</span> BrokerRegistry.getInstance().findFirst();</span><br><span class="line">                <span class="keyword">if</span> (broker == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;missing brokerURL (specified via &quot;</span> + BROKER_URL_INIT_PARAM + <span class="string">&quot; init-Param) or embedded broker&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    brokerURL = <span class="string">&quot;vm://&quot;</span> + broker.getBrokerName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOG.debug(<span class="string">&quot;Using broker URL: &quot;</span> + brokerURL);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getInitParameter(servletContext, USERNAME_INIT_PARAM);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> getInitParameter(servletContext, PASSWORD_INIT_PARAM);</span><br><span class="line">            <span class="type">ActiveMQConnectionFactory</span> <span class="variable">amqfactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(username, password, brokerURL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set prefetch policy for factory</span></span><br><span class="line">            <span class="keyword">if</span> (servletContext.getInitParameter(CONNECTION_FACTORY_PREFETCH_PARAM) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prefetch</span> <span class="operator">=</span> Integer.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_PREFETCH_PARAM)).intValue();</span><br><span class="line">                amqfactory.getPrefetchPolicy().setAll(prefetch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set optimize acknowledge setting</span></span><br><span class="line">            <span class="keyword">if</span> (servletContext.getInitParameter(CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">optimizeAck</span> <span class="operator">=</span> Boolean.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM)).booleanValue();</span><br><span class="line">                amqfactory.setOptimizeAcknowledge(optimizeAck);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            factory = amqfactory;</span><br><span class="line"></span><br><span class="line">            servletContext.setAttribute(CONNECTION_FACTORY_ATTRIBUTE, factory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面源码的ajaxServlet初始化方法中可以看到，首先从servlet的上下文中尝试获取ActiveMQConnectionFactory,如果没有设置则才会从上下文中找brokerURl进行初始化，所以我们可以继承AjaxServlet，然后在继承的servlet的init方法中按照需要创建ActiveMQConnectionFactory实例，然后将工厂实例添加到servlet上下文中供创建MQ连接使用。</p><h3 id="2-使用websocket实时获取报警数据"><a href="#2-使用websocket实时获取报警数据" class="headerlink" title="2.使用websocket实时获取报警数据"></a>2.使用websocket实时获取报警数据</h3><h3 id="3-websocket订阅ActiveMQ"><a href="#3-websocket订阅ActiveMQ" class="headerlink" title="3.websocket订阅ActiveMQ"></a>3.websocket订阅ActiveMQ</h3><h4 id="1-基于stomp协议"><a href="#1-基于stomp协议" class="headerlink" title="1)基于stomp协议"></a>1)基于stomp协议</h4><h4 id="2-基于mqtt协议"><a href="#2-基于mqtt协议" class="headerlink" title="2)基于mqtt协议"></a>2)基于mqtt协议</h4><h2 id="几种方案分析"><a href="#几种方案分析" class="headerlink" title="几种方案分析"></a>几种方案分析</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前端获取实时数据探索&quot;&gt;&lt;a href=&quot;#前端获取实时数据探索&quot; class=&quot;headerlink&quot; title=&quot;前端获取实时数据探索&quot;&gt;&lt;/a&gt;前端获取实时数据探索&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近在工作中，有个需求是前端需要获取实时展示最新的n条报警数据。使用http的请求响应，一问一答方式获取数据时，就出现可能部分数据获取不到的问题，然后在网上寻找和咨询老同事相关解决方案的时&lt;br&gt;候，发现有使用DWR的方式进行向前端推送的解决方案，&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://stxl117.top/categories/java/"/>
    
    
    <category term="java" scheme="https://stxl117.top/tags/java/"/>
    
    <category term="工作相关" scheme="https://stxl117.top/tags/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>python环境搭建</title>
    <link href="https://stxl117.top/2017/12/06/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://stxl117.top/2017/12/06/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2017-12-06T14:38:02.000Z</published>
    <updated>2024-06-30T09:09:16.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-安装笔记"><a href="#Python-安装笔记" class="headerlink" title="Python 安装笔记"></a>Python 安装笔记</h1><h2 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1.下载源码包"></a>1.下载源码包</h2><blockquote><p>wget <a href="https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz">https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz</a></p></blockquote><p>如果没有wget则可通过</p><blockquote><p>yum install wget</p></blockquote><p>安装wget</p><span id="more"></span><h2 id="2准备工作"><a href="#2准备工作" class="headerlink" title="2准备工作"></a>2准备工作</h2><p>检查当前linux系统中的ssl相关.so是否齐全：</p><blockquote><p>rpm -aq|grep openssl</p></blockquote><p>齐全情况应该如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">openssl</span>-devel-<span class="number">1</span>.<span class="number">0</span>.<span class="number">2</span>k-<span class="number">8</span>.el7.armv7hl</span><br><span class="line"><span class="attribute">openssl</span>-libs-<span class="number">1</span>.<span class="number">0</span>.<span class="number">2</span>k-<span class="number">8</span>.el7.armv7hl</span><br></pre></td></tr></table></figure><p>如果缺少则可通过</p><blockquote><p>yum install openssl openssl-devel</p></blockquote><p>进行补全安装</p><h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3.编译安装"></a>3.编译安装</h2><blockquote><p>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3</p></blockquote><blockquote><p>make &amp;&amp; make install</p></blockquote><p>就完成了基本的python源码安装，当下版本的python源码安装已经将pip集成在源码中，不需要在单独安装pip，就可以直接使用pip进行模块安装了</p><p>这里没有进行环境变量的配置而是直接在&#x2F;usr&#x2F;bin下建立了python3和pip的软连接，命令如下：</p><blockquote><p>ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python3<br>ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python-安装笔记&quot;&gt;&lt;a href=&quot;#Python-安装笔记&quot; class=&quot;headerlink&quot; title=&quot;Python 安装笔记&quot;&gt;&lt;/a&gt;Python 安装笔记&lt;/h1&gt;&lt;h2 id=&quot;1-下载源码包&quot;&gt;&lt;a href=&quot;#1-下载源码包&quot; class=&quot;headerlink&quot; title=&quot;1.下载源码包&quot;&gt;&lt;/a&gt;1.下载源码包&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;wget &lt;a href=&quot;https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz&quot;&gt;https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有wget则可通过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yum install wget&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装wget&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="https://stxl117.top/categories/python/"/>
    
    
    <category term="环境搭建" scheme="https://stxl117.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="python" scheme="https://stxl117.top/tags/python/"/>
    
    <category term="树莓派" scheme="https://stxl117.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
</feed>
